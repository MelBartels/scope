/*
copyright 1990 through 2009 by Mel Bartels

         This file is part of scope.exe the stepper version.

         Scope.exe is free software; you can redistribute it and/or modify
         it under the terms of the GNU General Public License as published by
         the Free Software Foundation; either version 2 of the License, or
         (at your option) any later version.

         Scope.exe is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
         GNU General Public License for more details.

         You should have received a copy of the GNU General Public License
         along with scope.exe; if not, write to the Free Software
         Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <math.h>
#include <time.h>
#include <dos.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <values.h>
#include <string.h>
#include <ctype.h>
#include <dir.h>
#include <process.h>
#include <graphics.h>
#include "header.h"

char SubVersionStr[] = " Additional features by Don Ware ";
char MainFrame_Title[] = " Scope Control Program compiled Aug 15, 2008 by Mel Bartels ";

void InitKBEvent( void)
{
        int IxA;

        SlewBeep = SlewOff;
        SlewBeepSound = 0;
        QuitFlag = No;
        JumboDisplayFlag = No;
        MsParmsAllowedFlag = No;
        LX200DisplayFlag = No;
        HoldLX200ComPort = LX200ComPort;
        FirstLinkFname = NULL;
        RaDecInit = NULL;
        FirstRaDecInit = NULL;
        FirstScroll = NULL;
        LastScroll = NULL;
        CurrentScroll = NULL;
        ScrollLoaded = No;
        ScrollUnderway = No;

        AutoGEMFlipOnFuzzRad = AutoGEMFlipOnFuzzDeg*DegToRad;
        AutoGEMFlipOffFuzzRad = AutoGEMFlipOffFuzzDeg*DegToRad;
        // following code sets boundaries for possible Safety Zone around meridian of GEM
        if( AutoGEMFlipOnFuzzRad + AutoGEMFlipOffFuzzRad < 0.0)
        {
          SafetyZoneFlag = True;
          SafetyZoneOnHigh = HalfRev - AutoGEMFlipOffFuzzRad;
          SafetyZoneOnLow = HalfRev + AutoGEMFlipOnFuzzRad;
          SafetyZoneOffHigh = fmod( OneRev - AutoGEMFlipOffFuzzRad, OneRev);
          SafetyZoneOffLow = fmod( OneRev + AutoGEMFlipOnFuzzRad, OneRev);
        }

        ETask = HTask = LTask = 0;
        KeyboardLeftButton = KeyboardRightButton = False;
        /* Set to 2 if Polar Alignment invoked */
        SelectObject = 1;
        PolarAlignmentStage = 0;

        DataFileNameSet = No;
        FocusFastDisplayFlag = True;

        GetCurDir( DefaultDir);
        GetCurDir( DataDir);

        strcpy( Filename, "bstars.dat");

        strcpy( GuideStartupMarFilePtr, InterfacePath);
        strcat( GuideStartupMarFilePtr, GuideStartupMarFile);
        strcpy( ScopeStartupMarFilePtr, InterfacePath);
        strcat( ScopeStartupMarFilePtr, ScopeStartupMarFile);

        strcpy( FullyQualifiedSlewFile, InterfacePath);
        strcat( FullyQualifiedSlewFile, SlewFile);
        strcpy( FullyQualifiedSlewOutFile, InterfacePath);
        strcat( FullyQualifiedSlewOutFile, SlewOutFile);

        OutGuideFilePtr = fopen( OutGuideFile, "w");
        if( OutGuideFilePtr == NULL)
                BadExit( strcat( "Could not open ", OutGuideFile));

        Output = fopen( InputFile, "w");
        if( Output == NULL)
                BadExit( strcat( "Could not open ", InputFile));
        fclose( Output);

        EncoderErrorThreshold = EncoderErrorThresholdDeg*DegToRad;
        TrackEncoderErrorThreshold = TrackEncoderErrorThresholdDeg*DegToRad;
        /* if encoder box has remained on since previous program shutdown... */
        if( ResetEncoderBox)
                SetEncoderAZandEncoderOffset();
        else
                /* offsets loaded from config.dat */
                CalcEncoderAZ();

        GuideFRAngleOffset = 0;

        /* GuideDrag from config.dat */
        /* altaz drag is in radians per minute */
        Drag.Alt = GuideDragAltArcsecPerMin * ArcsecToRad / ArcsecPerDeg;
        Drag.Az = GuideDragAzArcsecPerMin * ArcsecToRad / ArcsecPerDeg;
        /* equat drag is in radians per hour */
        /* equatorial drag is added to equat drift in AddDragToDrift() when HandpadFlag == GuideDragOn
                and DriftTick.Ra/Dec is added to Current.Ra in SequentialTaskController() */
        Drag.Ra = GuideDragRaArcsecPerMin * 60. * ArcsecToRad;
        Drag.Dec = GuideDragDecArcsecPerMin * 60. * ArcsecToRad;
        /* drag per bios clock tick */
        DragTick.Alt = Drag.Alt/ClockTicksMin;
        DragTick.Az = Drag.Az/ClockTicksMin;
        DragTick.Ra = Drag.Ra/ClockTicksHr;
        DragTick.Dec = Drag.Dec/ClockTicksHr;

        CalcHsMsgSteps();

        InitDisplayXY();

        MsgFrame.Left = 12;
        MsgFrame.Top = 9;
        MsgFrame.Right = 68;
        MsgFrame.Bottom = 17;
        MsgFrame.Title = " Message ";

        CoordFrame.Left = 1;
        CoordFrame.Top = 5;
        CoordFrame.Right = 80;
        CoordFrame.Bottom = 19;
        CoordFrame.Title = " Coordinates ";

        EPFrame.Left = 1;
        EPFrame.Top = 5;
        EPFrame.Right = 80;
        EPFrame.Bottom = 19;
        EPFrame.Title = " Eyepieces ";

        DataFileFrame.Left = 10;
        DataFileFrame.Top = 5;
        DataFileFrame.Right = 70;
        DataFileFrame.Bottom = 20;
        DataFileFrame.Title = " Data Files ";

        InitFrame.Left = 3;
        InitFrame.Top = 5;
        InitFrame.Right = 77;
        InitFrame.Bottom = 23;
        InitFrame.Title = " Initialization ";

        HotkeyFrame.Left = 4;
        HotkeyFrame.Top = 9;
        HotkeyFrame.Right = 76;
        HotkeyFrame.Bottom = 25;
        HotkeyFrame.Title = " Hotkeys ";

        HandpadFrame.Left = 10;
        HandpadFrame.Top = 6;
        HandpadFrame.Right = 70;
        HandpadFrame.Bottom = 20;
        HandpadFrame.Title = " Handpad Modes ";

        MainFrame.Left = 1;
        MainFrame.Top = 1;
        MainFrame.Right = MaxX;
        MainFrame.Bottom = MaxY;
        MainFrame.Title = MainFrame_Title;
        MainStr_9 =  "     Current      Input      Drift    Encoders     Refract   FieldRot   Focus";
        MainStr_10 = "Alt:                              \/m                        A";
        MainStr_11 = "Az:                               \/m                        R       \/m";
        MainStr_12 = "                                                            M";
        MainStr_13 = "Ra:                                 \/h      AirMass         M";
        MainStr_14 = "Dec:                                \/h  DomeAzimuth         G";
        MainStr_16 = "File                          Track       FRTrack      Init   GEMFlip";
        MainStr_17 = "Object                        Handpad";
        MainStr_18 = "Sidereal Time                 Mouse         Microstep    \"/sec  Guide   \"/sec";
        MainStr_19 = "Date/Time                     FastFocus    /sec   SlowFocus    /sec";
        MainStr_20 = "                              PWM         Ms                    QSC";
        MainStr_21 = "PEC                           AZEC       AAEC       ZZEC       PMC";
        MainStr_22 = "Slew";
        MainStr_23 = "LX200";

        Ix = 0;
        InitText[Ix++] = "InitEquatorial    ";
        InitText[Ix++] = "InitAltazimuth    ";
        InitText[Ix++] = "InitAltAlt        ";
        InitText[Ix++] = "NoInit            ";
        InitText[Ix++] = "InitFromConfigFile";

        Ix = 0;
        SlewText[Ix++] =        "RampU";
        SlewText[Ix++] =        "MaxU ";
        SlewText[Ix++] =        "MaxD ";
        SlewText[Ix++] =        "RampD";
        SlewText[Ix++] =        "Done ";

        Ix = 0;
        AbortText[Ix++] = "           ";
        AbortText[Ix++] =       "HPad-Abort ";
        AbortText[Ix++] =       "Mouse-Abort";
        AbortText[Ix++] =       "KeyB-Abort ";
        AbortText[Ix++] =       "LX200-Abort";
        AbortText[Ix++] =       "AltLo-Abort";
        AbortText[Ix++] =       "AltHi-Abort";
        AbortText[Ix++] =       "AzLo-Abort ";
        AbortText[Ix++] =       "AzHi-Abort ";
        AbortText[Ix++] =       "GEMfp-Abort";

        Ix = 0;
        HPStr[Ix++] = "Off        ";
        HPStr[Ix++] = "InitAutoOn ";
        HPStr[Ix++] = "Init1On    ";
        HPStr[Ix++] = "Init2On    ";
        HPStr[Ix++] = "Init3On    ";
        HPStr[Ix++] = "PolarAlign ";
        HPStr[Ix++] = "AnalyzeOn  ";
        HPStr[Ix++] = "Guide      ";
        HPStr[Ix++] = "GuideStay  ";
        HPStr[Ix++] = "GuideStayRo";
        HPStr[Ix++] = "GuideDrag  ";
        HPStr[Ix++] = "GrandTour  ";
        HPStr[Ix++] = "ScrollTour ";
        HPStr[Ix++] = "ScrollAuto ";
        HPStr[Ix++] = "RecordEquat";
        HPStr[Ix++] = "ToggleTrack";
        HPStr[Ix++] = "FRMotorCtrl";
        HPStr[Ix++] = "Focus      ";
        HPStr[Ix++] = "AuxOutCtrl ";

        IxA = 0;
        Ix = 0;
        MenuArray[IxA].Title = "File";
        MenuArray[IxA].SubTitles[Ix].Title = "Quit";
        MenuArray[IxA].SubTitles[Ix].Desc = "quit the program";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuQuit;
        MenuArray[IxA].SubTitles[Ix].Title = "Site";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter new site coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSite;
        MenuArray[IxA].SubTitles[Ix].Title = "SaveCfg";
        MenuArray[IxA].SubTitles[Ix].Desc = "save the current configuration to the config.dat file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSaveConfigFile;
        MenuArray[IxA].SubTitles[Ix].Title = "DataFile";
        MenuArray[IxA].SubTitles[Ix].Desc = "select an object from a data file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDataFile;
        MenuArray[IxA].SubTitles[Ix].Title = "DataFile2";
        MenuArray[IxA].SubTitles[Ix].Desc = "find closest object in a data file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDataFileClosest;
        MenuArray[IxA].SubTitles[Ix].Title = "DataFile3";
        MenuArray[IxA].SubTitles[Ix].Desc = "find closest object in a data file that is not same as input";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDataFileClosestNotSame;
        MenuArray[IxA].SubTitles[Ix].Title = "DataFile4";
        MenuArray[IxA].SubTitles[Ix].Desc = "find closest object in a data file that that has not been input";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDataFileClosestNotInputFile;
        MenuArray[IxA].SubTitles[Ix].Title = "SearchData";
        MenuArray[IxA].SubTitles[Ix].Desc = "search data files for object";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSearchDataFiles;
        MenuArray[IxA].SubTitles[Ix].Title = "ClosestGT";
        MenuArray[IxA].SubTitles[Ix].Desc = "set grand tour so that next object is closest to current equat coord";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGrandTourClosest;
        MenuArray[IxA].SubTitles[Ix].Title = "ScrollTour";
        MenuArray[IxA].SubTitles[Ix].Desc = "load a file of slow smooth scrolling motions";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuScrollTour;
        MenuArray[IxA].SubTitles[Ix].Title = "MinorPlanets";
        MenuArray[IxA].SubTitles[Ix].Desc = "select an object from a minor planet file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMinorPlanets;
        MenuArray[IxA].SubTitles[Ix].Title = "InputComment";
        MenuArray[IxA].SubTitles[Ix].Desc = "write a comment to the input.dat";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuWriteInputComment;
        MenuArray[IxA].SubTitles[Ix].Title = "DOSShell";
        MenuArray[IxA].SubTitles[Ix].Desc = "shell to DOS";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDosShell;
        MenuArray[IxA].SubTitles[Ix].Title = "Guide.bat";
        MenuArray[IxA].SubTitles[Ix].Desc = "call DOS version of Project Pluto Guide (cd-rom)";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGuide;
        MenuArray[IxA].SubTitles[Ix].Title = "ReadSlew";
        MenuArray[IxA].SubTitles[Ix].Desc = "read slew file generated by external control program";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuReadSlew;
        MenuArray[IxA].SubTitles[Ix].Title = "WriteSlew";
        MenuArray[IxA].SubTitles[Ix].Desc = "write slew file for use by external control program";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuWriteSlew;
        MenuArray[IxA].SubTitles[Ix].Title = "LX200";
        MenuArray[IxA].SubTitles[Ix].Desc = "toggle LX200 command link and toggle display";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuLX200Control;
        MenuArray[IxA].SubTitles[Ix].Title = "Screen";
        MenuArray[IxA].SubTitles[Ix].Desc = "select between standard display, jumbo display, or no updating";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuScreen;
        MenuArray[IxA].SubTitles[Ix].Title = "UserHotkeys";
        MenuArray[IxA].SubTitles[Ix].Desc = "user defined hotkeys";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuUserDefinedHotkeys;
        MenuArray[IxA].SubTitles[Ix].Title = "Hotkeys";
        MenuArray[IxA].SubTitles[Ix].Desc = "display a listing of hotkeys";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHotkeys;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "Motors";
        MenuArray[IxA].SubTitles[Ix].Title = "TrackOn/Off";
        MenuArray[IxA].SubTitles[Ix].Desc = "toggle tracking on and off";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuTrack;
        MenuArray[IxA].SubTitles[Ix].Title = "FRTrackOn/Off";
        MenuArray[IxA].SubTitles[Ix].Desc = "toggle field rotation motor tracking on and off";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuFRMotorTrack;
        MenuArray[IxA].SubTitles[Ix].Title = "DecOn/Off";
        MenuArray[IxA].SubTitles[Ix].Desc = "Enable or disable the Declination motor to microstep";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDecMotor;
        MenuArray[IxA].SubTitles[Ix].Title = "ReverseAZMtrs";
        MenuArray[IxA].SubTitles[Ix].Desc = "Reverse the altitude and azimuth motor directions";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuReverseAZMotors;
        MenuArray[IxA].SubTitles[Ix].Title = "ReverseFRMotor";
        MenuArray[IxA].SubTitles[Ix].Desc = "Reverse the field rotation motor direction";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuReverseFRMotor;
        MenuArray[IxA].SubTitles[Ix].Title = "ReverseFocuser";
        MenuArray[IxA].SubTitles[Ix].Desc = "Reverse the focuser motor direction";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuReverseFocusMotor;
        MenuArray[IxA].SubTitles[Ix].Title = "AZStepSizes";
        MenuArray[IxA].SubTitles[Ix].Desc = "change the fullstep sizes of both drive steppers";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuStepsizes;
        MenuArray[IxA].SubTitles[Ix].Title = "FRStepSize";
        MenuArray[IxA].SubTitles[Ix].Desc = "set the field rotation motor's step size";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuFRStepsize;
        MenuArray[IxA].SubTitles[Ix].Title = "MsSpeed";
        MenuArray[IxA].SubTitles[Ix].Desc = "set the microstepping speed";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMsSpeed;
        MenuArray[IxA].SubTitles[Ix].Title = "GuideSpeed";
        MenuArray[IxA].SubTitles[Ix].Desc = "set the speed to use during guide mode";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGuideSpeed;
        MenuArray[IxA].SubTitles[Ix].Title = "FocusFastSpeed";
        MenuArray[IxA].SubTitles[Ix].Desc = "set the fast focus speed";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuFocusFastSpeed;
        MenuArray[IxA].SubTitles[Ix].Title = "FocusSlowSpeed";
        MenuArray[IxA].SubTitles[Ix].Desc = "set the slow focus speed";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuFocusSlowSpeed;
        MenuArray[IxA].SubTitles[Ix].Title = "HsParms";
        MenuArray[IxA].SubTitles[Ix].Desc = "change halfstepping parameters";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuChangeHsParms;
        MenuArray[IxA].SubTitles[Ix].Title = "MsParms";
        MenuArray[IxA].SubTitles[Ix].Desc = "change microstepping parameters";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuChangeMsParms;
        MenuArray[IxA].SubTitles[Ix].Title = "AutoMsParms";
        MenuArray[IxA].SubTitles[Ix].Desc = "set MsDelayX & MsPause based on PWMRepsTick & motor current percentage";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAutoMsParms;
        MenuArray[IxA].SubTitles[Ix].Title = "Backlash";
        MenuArray[IxA].SubTitles[Ix].Desc = "change backlash parameters";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuChangeBacklashParms;
        MenuArray[IxA].SubTitles[Ix].Title = "ZeroBacklash";
        MenuArray[IxA].SubTitles[Ix].Desc = "zero out backlash";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuZeroBacklash;
        MenuArray[IxA].SubTitles[Ix].Title = "AutoGEMFlip";
        MenuArray[IxA].SubTitles[Ix].Desc = "turn on/off the auto German Equatorial Mount meridian flip";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAutoGEMFlipOnOff;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "Handpad";
        MenuArray[IxA].SubTitles[Ix].Title = "Design";
        MenuArray[IxA].SubTitles[Ix].Desc = "select a hand paddle design";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHandpadDesign;
        MenuArray[IxA].SubTitles[Ix].Title = "HandpadMode";
        MenuArray[IxA].SubTitles[Ix].Desc = "cycle through hand paddle mode settings";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHandpad;
        MenuArray[IxA].SubTitles[Ix].Title = "SelectHPMode";
        MenuArray[IxA].SubTitles[Ix].Desc = "select a hand paddle mode";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSelectHandpadMode;
        MenuArray[IxA].SubTitles[Ix].Title = "HPUpdateDrift";
        MenuArray[IxA].SubTitles[Ix].Desc = "toggle auto update of drift from handpad guiding modes";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHPUpdateDrift;
        MenuArray[IxA].SubTitles[Ix].Title = "FlipButtons";
        MenuArray[IxA].SubTitles[Ix].Desc = "reverse up, down hand paddle buttons";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuReverseUpDownButtons;
        MenuArray[IxA].SubTitles[Ix].Title = "GuideAngle";
        MenuArray[IxA].SubTitles[Ix].Desc = "rotate action of handpad's guiding buttons to new angle";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuChangeGuideFRAngle;
        MenuArray[IxA].SubTitles[Ix].Title = "ModeSwitchLeft";
        MenuArray[IxA].SubTitles[Ix].Desc = "simulate handpad mode switch move to the left";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHandpadLeft;
        MenuArray[IxA].SubTitles[Ix].Title = "ModeSwitchRight";
        MenuArray[IxA].SubTitles[Ix].Desc = "simulate handpad mode switch move to the right";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHandpadRight;
        MenuArray[IxA].SubTitles[Ix].Title = "SpeedSwitch";
        MenuArray[IxA].SubTitles[Ix].Desc = "flip flop between microstepping and halfstepping speeds";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHandpadSpeed;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "EC";
        MenuArray[IxA].SubTitles[Ix].Title = "PECDisplay";
        MenuArray[IxA].SubTitles[Ix].Desc = "display working PEC in memory";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECDisplay;
        MenuArray[IxA].SubTitles[Ix].Title = "PECOn/Off";
        MenuArray[IxA].SubTitles[Ix].Desc = "toggle periodic error correction on and off";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECOnOff;
        MenuArray[IxA].SubTitles[Ix].Title = "PEC Synch Alt";
        MenuArray[IxA].SubTitles[Ix].Desc = "synchronize Altitude PEC";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECSynchAlt;
        MenuArray[IxA].SubTitles[Ix].Title = "PEC Synch Az";
        MenuArray[IxA].SubTitles[Ix].Desc = "synchronize Azimuth PEC";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECSynchAz;
        MenuArray[IxA].SubTitles[Ix].Title = "PECZeroOut";
        MenuArray[IxA].SubTitles[Ix].Desc = "zero out working PEC data in memory";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECZeroOut;
        MenuArray[IxA].SubTitles[Ix].Title = "PECReload";
        MenuArray[IxA].SubTitles[Ix].Desc = "reload PEC from PECFile";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECReload;
        MenuArray[IxA].SubTitles[Ix].Title = "PECGuide->A";
        MenuArray[IxA].SubTitles[Ix].Desc = "extract altitude/declination PEC data from guiding efforts";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECGuidingAltDisplay;
        MenuArray[IxA].SubTitles[Ix].Title = "PECGuide->Z";
        MenuArray[IxA].SubTitles[Ix].Desc = "extract azimuth/right ascension PEC data from guiding efforts";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECGuidingAzDisplay;
        MenuArray[IxA].SubTitles[Ix].Title = "PECAvg";
        MenuArray[IxA].SubTitles[Ix].Desc = "average the PEC data files created from guiding efforts";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECAverageFiles;
        MenuArray[IxA].SubTitles[Ix].Title = "PECMedian";
        MenuArray[IxA].SubTitles[Ix].Desc = "use a median filter to smooth the PEC curves";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPECMedianSmooth;
        MenuArray[IxA].SubTitles[Ix].Title = "AltAzEC";
        MenuArray[IxA].SubTitles[Ix].Desc = "graph the altitude vs azimuth errors using the analysis file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAltAzEC;
        MenuArray[IxA].SubTitles[Ix].Title = "AltAzECOnOff";
        MenuArray[IxA].SubTitles[Ix].Desc = "turn on or off the altitude vs azimuth error corrections";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAltAzECOnOff;
        MenuArray[IxA].SubTitles[Ix].Title = "AltAltEC";
        MenuArray[IxA].SubTitles[Ix].Desc = "graph the altitude vs altitude errors using the analysis file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAltAltEC;
        MenuArray[IxA].SubTitles[Ix].Title = "AltAltECOnOff";
        MenuArray[IxA].SubTitles[Ix].Desc = "turn on or off the altitude vs altitude error corrections";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAltAltECOnOff;
        MenuArray[IxA].SubTitles[Ix].Title = "AzAzEC";
        MenuArray[IxA].SubTitles[Ix].Desc = "graph the azimith vs azimuth errors using the analysis file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAzAzEC;
        MenuArray[IxA].SubTitles[Ix].Title = "AzAzECOnOff";
        MenuArray[IxA].SubTitles[Ix].Desc = "turn on or off the azimith vs azimuth error corrections";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAzAzECOnOff;
        MenuArray[IxA].SubTitles[Ix].Title = "Analysis->PMC";
        MenuArray[IxA].SubTitles[Ix].Desc = "add the analysis file to the Pointing Model Corrections file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAnalysisToPMC;
        MenuArray[IxA].SubTitles[Ix].Title = "GraphPMC";
        MenuArray[IxA].SubTitles[Ix].Desc = "graph the Pointing Model Corrections";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGraphPMC;
        MenuArray[IxA].SubTitles[Ix].Title = "PMCOnOff";
        MenuArray[IxA].SubTitles[Ix].Desc = "turn on or off the Pointing Model Corrections";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPMCOnOff;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "Init";
        MenuArray[IxA].SubTitles[Ix].Title = "DisplayInits";
        MenuArray[IxA].SubTitles[Ix].Desc = "display the initialization settings";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDisplayInit;
        MenuArray[IxA].SubTitles[Ix].Title = "KillInits";
        MenuArray[IxA].SubTitles[Ix].Desc = "kill all initializations";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuKillInits;
        MenuArray[IxA].SubTitles[Ix].Title = "EnterInit1";
        MenuArray[IxA].SubTitles[Ix].Desc = "manually enter initialization position #1";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuEnterInit1;
        MenuArray[IxA].SubTitles[Ix].Title = "EnterInit2";
        MenuArray[IxA].SubTitles[Ix].Desc = "manually enter initialization position #2";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuEnterInit2;
        MenuArray[IxA].SubTitles[Ix].Title = "EnterInit3";
        MenuArray[IxA].SubTitles[Ix].Desc = "manually enter initialization position #3";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuEnterInit3;
        MenuArray[IxA].SubTitles[Ix].Title = "CloseInit";
        MenuArray[IxA].SubTitles[Ix].Desc = "assign closest position to init #1 from analysis file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuClosestInit;
        MenuArray[IxA].SubTitles[Ix].Title = "Init1";
        MenuArray[IxA].SubTitles[Ix].Desc = "init position #1 using current altaz and input equat";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuInit1;
        MenuArray[IxA].SubTitles[Ix].Title = "Init2";
        MenuArray[IxA].SubTitles[Ix].Desc = "init position #2 using current altaz and input equat";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuInit2;
        MenuArray[IxA].SubTitles[Ix].Title = "Init3";
        MenuArray[IxA].SubTitles[Ix].Desc = "init position #3 using current altaz and input equat";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuInit3;
        MenuArray[IxA].SubTitles[Ix].Title = "InputZ1Z2Z3";
        MenuArray[IxA].SubTitles[Ix].Desc = "input new mount misalignment parameters Z1, Z2, and Z3";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSetZ1Z2Z3;
        MenuArray[IxA].SubTitles[Ix].Title = "AltOffset";
        MenuArray[IxA].SubTitles[Ix].Desc = "calc. altitude offset Z3 using init #1, #2, then re-init";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAltOffset;
        MenuArray[IxA].SubTitles[Ix].Title = "AzOff+Axis";
        MenuArray[IxA].SubTitles[Ix].Desc = "calc. az. offset Z2 & axis align Z1 using init #1, #2, #3, then re-init";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAzOffsetAxisAlign;
        MenuArray[IxA].SubTitles[Ix].Title = "GraphAnalysis";
        MenuArray[IxA].SubTitles[Ix].Desc = "graph the analysis file with pointing errors, saving to pointerr.dat";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGraphAnalysis;
        MenuArray[IxA].SubTitles[Ix].Title = "PurgeAnalysis";
        MenuArray[IxA].SubTitles[Ix].Desc = "purge the analysis file, renaming it to analysis.old";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPurgeAnalysis;
        MenuArray[IxA].SubTitles[Ix].Title = "AnalyzeZ1Z2Z3";
        MenuArray[IxA].SubTitles[Ix].Desc = "automatically calculate the alignment parms Z1, Z2, Z3 using analysis file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuAnalysisBestZ1Z2Z3;
        MenuArray[IxA].SubTitles[Ix].Title = "GraphZ1Z2Z3";
        MenuArray[IxA].SubTitles[Ix].Desc = "graph & change the mount alignment parms Z1, Z2, Z3 using analysis file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGraphZ1Z2Z3;
        MenuArray[IxA].SubTitles[Ix].Title = "PolarAlign";
        MenuArray[IxA].SubTitles[Ix].Desc = "move the scope through a 3 star polar align process";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuPolarAlign;
        MenuArray[IxA].SubTitles[Ix].Title = "AnalysisPt";
        MenuArray[IxA].SubTitles[Ix].Desc = "write a data point to the analysis file";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuWriteAnalysisPoint;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "Coord";
        MenuArray[IxA].SubTitles[Ix].Title = "InputEquat";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter new input equatorial coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuInputEquat;
        MenuArray[IxA].SubTitles[Ix].Title = "InputEq->Alt";
        MenuArray[IxA].SubTitles[Ix].Desc = "convert input equatorial coordinates to input altazimuth coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuInputEquatToAltaz;
        MenuArray[IxA].SubTitles[Ix].Title = "OffsetEquat";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter offset from current equatorial coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuOffsetEquat;
        MenuArray[IxA].SubTitles[Ix].Title = "DriftEquat";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter equatorial drift values";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDriftEquat;
        MenuArray[IxA].SubTitles[Ix].Title = "InputAltaz";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter new input altazimuth coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuInputAltaz;
        MenuArray[IxA].SubTitles[Ix].Title = "OffsetAltaz";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter offset from current altazimuth coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuOffsetAltaz;
        MenuArray[IxA].SubTitles[Ix].Title = "DriftAltaz";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter altazimuth drift values";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuDriftAltaz;
        MenuArray[IxA].SubTitles[Ix].Title = "ZeroDrift";
        MenuArray[IxA].SubTitles[Ix].Desc = "zero drift values";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuZeroDrift;
        MenuArray[IxA].SubTitles[Ix].Title = "ResetDrift";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset drift values";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuResetDrift;
        MenuArray[IxA].SubTitles[Ix].Title = "AccumDrift";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset accumulated drift";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuResetAccumDrift;
        MenuArray[IxA].SubTitles[Ix].Title = "Save1";
        MenuArray[IxA].SubTitles[Ix].Desc = "saves current equatorial coordinates into #1 buffer";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSav1;
        MenuArray[IxA].SubTitles[Ix].Title = "Restore1";
        MenuArray[IxA].SubTitles[Ix].Desc = "restore saved #1 equatorial coordinates into input fields";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuRes1;
        MenuArray[IxA].SubTitles[Ix].Title = "Save2";
        MenuArray[IxA].SubTitles[Ix].Desc = "saves current equatorial coordinates into #2 buffer";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSav2;
        MenuArray[IxA].SubTitles[Ix].Title = "Restore2";
        MenuArray[IxA].SubTitles[Ix].Desc = "restore saved #2 equatorial coordinates into input fields";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuRes2;
        MenuArray[IxA].SubTitles[Ix].Title = "LastObject";
        MenuArray[IxA].SubTitles[Ix].Desc = "restore last selected object from the data files";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuRestoreLastObject;
        MenuArray[IxA].SubTitles[Ix].Title = "Home";
        MenuArray[IxA].SubTitles[Ix].Desc = "enter new altazimuth home coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuHomeCoord;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "Move";
        MenuArray[IxA].SubTitles[Ix].Title = "Equat";
        MenuArray[IxA].SubTitles[Ix].Desc = "move to input equatorial coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveEquat;
        MenuArray[IxA].SubTitles[Ix].Title = "Altaz";
        MenuArray[IxA].SubTitles[Ix].Desc = "move to input altazimuth coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveAltaz;
        MenuArray[IxA].SubTitles[Ix].Title = "Home";
        MenuArray[IxA].SubTitles[Ix].Desc = "move to home coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveHome;
        MenuArray[IxA].SubTitles[Ix].Title = "Halfsteps";
        MenuArray[IxA].SubTitles[Ix].Desc = "move a certain number of halfsteps";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveHs;
        MenuArray[IxA].SubTitles[Ix].Title = "Microsteps";
        MenuArray[IxA].SubTitles[Ix].Desc = "move a certain number of microsteps";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveMs;
        MenuArray[IxA].SubTitles[Ix].Title = "GEMFlip";
        MenuArray[IxA].SubTitles[Ix].Desc = "move the telescope in a German Equatorial Mount meridian flip";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveGEMFlip;
        MenuArray[IxA].SubTitles[Ix].Title = "MoveToZeroPEC";
        MenuArray[IxA].SubTitles[Ix].Desc = "move motors such that the PEC index is zero (at the PEC synch points)";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveZeroPEC;
        MenuArray[IxA].SubTitles[Ix].Title = "2MotorTrack";
        MenuArray[IxA].SubTitles[Ix].Desc = "track both motors using a starting rate of motion and acceleration";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = Menu2MotorTrack;
        MenuArray[IxA].SubTitles[Ix].Title = "TrackEncoder";
        MenuArray[IxA].SubTitles[Ix].Desc = "microstep the motors and record encoder counts";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuTrackEncoder;
        MenuArray[IxA].SubTitles[Ix].Title = "MoveFocus";
        MenuArray[IxA].SubTitles[Ix].Desc = "move the focus motor to a particular position";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveFocus;
        MenuArray[IxA].SubTitles[Ix].Title = "FocusEyepiece";
        MenuArray[IxA].SubTitles[Ix].Desc = "move the focus motor to a particular eyepiece";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuMoveFocusEP;
        MenuArray[IxA].SubTitles[Ix].Title = "SaveEPfocus";
        MenuArray[IxA].SubTitles[Ix].Desc = "save the eyepiece's focus position";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuSaveFocusEP;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "Reset";
        MenuArray[IxA].SubTitles[Ix].Title = "Equat";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset to input equatorial coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuResetEquat;
        MenuArray[IxA].SubTitles[Ix].Title = "Altaz";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset to input altazimuth coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuResetAltaz;
        MenuArray[IxA].SubTitles[Ix].Title = "Home";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset to home coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuResetHome;
        MenuArray[IxA].SubTitles[Ix].Title = "InitEncoders";
        MenuArray[IxA].SubTitles[Ix].Desc = "re-initialize the encoder interface box";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuInitEncoders;
        MenuArray[IxA].SubTitles[Ix].Title = "ResetEncoders";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset to encoder coordinates";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuResetToEncoders;
        MenuArray[IxA].SubTitles[Ix].Title = "manual GEMFlip";
        MenuArray[IxA].SubTitles[Ix].Desc = "do a manual GEM meridian flip";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGEMMeridianFlip;
        MenuArray[IxA].SubTitles[Ix].Title = "GEMFlip OK";
        MenuArray[IxA].SubTitles[Ix].Desc = "change GEM flip possible state";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuGEMFlipPossible;
        MenuArray[IxA].SubTitles[Ix].Title =  "FieldRot";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset field rotation motor to current field rotation angle";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuFRReset;
        MenuArray[IxA].SubTitles[Ix].Title =  "Focus";
        MenuArray[IxA].SubTitles[Ix].Desc = "reset focus motor position";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuResetFocus;
        MenuArray[IxA].NumSubTitles = Ix;

        IxA++;
        Ix = 0;
        MenuArray[IxA].Title = "Test";
        MenuArray[IxA].SubTitles[Ix].Title = "TestSerial";
        MenuArray[IxA].SubTitles[Ix].Desc = "test a serial port by entering terminal mode";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuTestSerial;
        MenuArray[IxA].SubTitles[Ix].Title = "TestPPort";
        MenuArray[IxA].SubTitles[Ix].Desc = "test the parallel port";
        MenuArray[IxA].SubTitles[Ix++].MenuItem = MenuTestPPort;
        MenuArray[IxA].NumSubTitles = Ix;

        if( DisplayOpeningMsgs)
                PrelimMsg();
        else
                TurnOnMotorsSnd();

        SetAttributes();

        /* setup screen */
        _wscroll = No;
        _setcursortype( _NOCURSOR);
        Clrscr();

        /* build Hotkey descriptions */
        BuildHotkeyStrings();

        /* write main window */
        DrawBorder( MainFrame);
        DrawScreenLine( DisplayLine1Y);

        /* write display titles */
        TextAttr = DefaultText;
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = MenuCoordTitleY;
        sprintf( StrBuf, "%s", MainStr_9);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayAltY;
        sprintf( StrBuf, "%s", MainStr_10);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayAzY;
        sprintf( StrBuf, "%s", MainStr_11);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayFRMotorAngleY;
        sprintf( StrBuf, "%s", MainStr_12);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayRaY;
        sprintf( StrBuf, "%s", MainStr_13);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayDecY;
        sprintf( StrBuf, "%s", MainStr_14);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayFileY;
        sprintf( StrBuf, "%s", MainStr_16);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayObjectY;
        sprintf( StrBuf, "%s", MainStr_17);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplaySidTY;
        sprintf( StrBuf, "%s", MainStr_18);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayDateTimeY;
        sprintf( StrBuf, "%s", MainStr_19);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayPWMY;
        sprintf( StrBuf, "%s", MainStr_20);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayPECY;
        sprintf( StrBuf, "%s", MainStr_21);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplaySlewY;
        sprintf( StrBuf, "%s", MainStr_22);
        WriteStrBufToScreen_f_ptr();
        VidMemXY.X = MenuStartX;
        VidMemXY.Y = DisplayLX200Y;
        sprintf( StrBuf, "%s", MainStr_23);
        WriteStrBufToScreen_f_ptr();
        TextAttr = TitleText;
        VidMemXY.X = MenuStartX + 40-floor( strlen( SubVersionStr)/2);
        VidMemXY.Y = DisplayLX200Y+1;
        sprintf( StrBuf, "%s", SubVersionStr);
        WriteStrBufToScreen_f_ptr();

        WriteHandpadStatus();
        WriteTrackStatus();
        WriteFRMotorTrackStatus();
        WritePECSynchStatus();
        WriteMsArcsecSec();
        WriteGuideArcsecSec();
        WriteFocusFastSpeed();
        WriteFocusSlowSpeed();
        if( FocusMethod == FocusMethod_Pulse_1_14 || FocusMethod == FocusMethod_Pulse_16_17)
                WriteFocusPosition();
        In = Current;
        DisplayIn( NameBlanks, NameBlanks);
        DisplayDrift();
        DisplayInitStatusOnScreen();
        DisplayGEMFlipStatus();
        DisplayLX200CommandStatus();
        DisplayMsValues_f_ptr();
        if( UseMouseFlag)
                WriteMouseMode();

        /* fill out the array of menu category video memory X values */
        for( Ix = 0; Ix < MaxMenuCats; Ix++)
                MenuCatX[Ix] = MenuStartX + Ix*(MenuEndX-MenuStartX)/MaxMenuCats;
        /* fill out the array of menu subtitle video memory X values */
        for( Ix = 0; Ix < MaxMenuSubs; Ix++)
                MenuSubX[Ix] = MenuStartX + Ix*(MenuEndX-MenuStartX)/MaxMenuSubs;
        /* start program with first category and first subtitle of that category */
        CurrentMenuCat = 0;
        CurrentMenuSub = 0;
        NewMenuCat = 0;
        NewMenuSub = 0;
        WriteMainMenu();
}

void SetAttributes( void)
{
        MenuText = MenuColor + (DefaultBackground << 4);
        SelectText = SelectColor + (SelectBackground << 4);
        CurrentText = CurrentColor + (DefaultBackground << 4);
        DisplayText = DisplayColor + (DefaultBackground << 4);
        DefaultText = DefaultColor + (DefaultBackground << 4);
        BorderText = BorderColor + (DefaultBackground << 4);
        TitleText = TitleColor + (DefaultBackground << 4);
}

void InitDisplayXY( void)
{
        DisplayXY[DisplayCurrentAlt].X = DisplayCurrentX;
        DisplayXY[DisplayCurrentAlt].Y = DisplayAltY;
        DisplayXY[DisplayInputAlt].X = DisplayInputX;
        DisplayXY[DisplayInputAlt].Y = DisplayAltY;
        DisplayXY[DisplayDriftAlt].X = DisplayDriftX;
        DisplayXY[DisplayDriftAlt].Y = DisplayAltY;
        DisplayXY[DisplayEncoderAlt].X = DisplayEncoderX;
        DisplayXY[DisplayEncoderAlt].Y = DisplayAltY;
        DisplayXY[DisplayEncoderCountAlt].X = DisplayEncoderCountX;
        DisplayXY[DisplayEncoderCountAlt].Y = DisplayAltY;
        DisplayXY[DisplayRefract].X = DisplayRefractX;
        DisplayXY[DisplayRefract].Y = DisplayAltY;
        DisplayXY[DisplayFR].X = DisplayFRX;
        DisplayXY[DisplayFR].Y = DisplayAltY;
        DisplayXY[DisplayFocusPosition].X = DisplayFocusPositionX;
        DisplayXY[DisplayFocusPosition].Y = DisplayAltY;
        DisplayXY[DisplayCurrentAz].X = DisplayCurrentX;
        DisplayXY[DisplayCurrentAz].Y = DisplayAzY;
        DisplayXY[DisplayInputAz].X = DisplayInputX;
        DisplayXY[DisplayInputAz].Y = DisplayAzY;
        DisplayXY[DisplayDriftAz].X = DisplayDriftX;
        DisplayXY[DisplayDriftAz].Y = DisplayAzY;
        DisplayXY[DisplayEncoderAz].X = DisplayEncoderX;
        DisplayXY[DisplayEncoderAz].Y = DisplayAzY;
        DisplayXY[DisplayEncoderCountAz].X = DisplayEncoderCountX;
        DisplayXY[DisplayEncoderCountAz].Y = DisplayAzY;
        DisplayXY[DisplayFRRate].X = DisplayFRX;
        DisplayXY[DisplayFRRate].Y = DisplayAzY;
        DisplayXY[DisplayFRMotorAngle].X = DisplayFRX;
        DisplayXY[DisplayFRMotorAngle].Y = DisplayFRMotorAngleY;
        DisplayXY[DisplayCurrentRa].X = DisplayCurrentX;
        DisplayXY[DisplayCurrentRa].Y = DisplayRaY;
        DisplayXY[DisplayInputRa].X = DisplayInputX;
        DisplayXY[DisplayInputRa].Y = DisplayRaY;
        DisplayXY[DisplayDriftRa].X = DisplayDriftX;
        DisplayXY[DisplayDriftRa].Y = DisplayRaY;
        DisplayXY[DisplayAirMass].X = DisplayRefractX;
        DisplayXY[DisplayAirMass].Y = DisplayRaY;
        DisplayXY[DisplayFRMotorPulses].X = DisplayFRX;
        DisplayXY[DisplayFRMotorPulses].Y = DisplayRaY;
        DisplayXY[DisplayCurrentDec].X = DisplayCurrentX;
        DisplayXY[DisplayCurrentDec].Y = DisplayDecY;
        DisplayXY[DisplayInputDec].X = DisplayInputX;
        DisplayXY[DisplayInputDec].Y = DisplayDecY;
        DisplayXY[DisplayDriftDec].X = DisplayDriftX;
        DisplayXY[DisplayDriftDec].Y = DisplayDecY;
        DisplayXY[DisplayDomeAzimuth].X = DisplayRefractX;
        DisplayXY[DisplayDomeAzimuth].Y = DisplayDecY;
        DisplayXY[DisplayFRGuideAngle].X = DisplayFRX;
        DisplayXY[DisplayFRGuideAngle].Y = DisplayDecY;
        DisplayXY[DisplayFile].X = DisplayFileX;
        DisplayXY[DisplayFile].Y = DisplayFileY;
        DisplayXY[DisplayScrollCounts].X = DisplayScrollCountsX;
        DisplayXY[DisplayScrollCounts].Y = DisplayScrollCountsY;
        DisplayXY[DisplayTrack].X = DisplayTrackX;
        DisplayXY[DisplayTrack].Y = DisplayTrackY;
        DisplayXY[DisplayFRMotorTrack].X = DisplayFRMotorTrackX;
        DisplayXY[DisplayFRMotorTrack].Y = DisplayTrackY;
        DisplayXY[DisplayInitStatus].X = DisplayInitX;
        DisplayXY[DisplayInitStatus].Y = DisplayInitY;
        DisplayXY[DisplayGEMFlip].X = DisplayGEMFlipX;
        DisplayXY[DisplayGEMFlip].Y = DisplayGEMFlipY;
        DisplayXY[DisplayObject].X = DisplayObjectX;
        DisplayXY[DisplayObject].Y = DisplayObjectY;
        DisplayXY[DisplayHandpad].X = DisplayHandpadX;
        DisplayXY[DisplayHandpad].Y = DisplayHandpadY;
        DisplayXY[DisplayButtons].X = DisplayButtonsX;
        DisplayXY[DisplayButtons].Y = DisplayButtonsY;
        DisplayXY[DisplaySidT].X = DisplaySidTX;
        DisplayXY[DisplaySidT].Y = DisplaySidTY;
        DisplayXY[DisplayMouseMode].X = DisplayMouseModeX;
        DisplayXY[DisplayMouseMode].Y = DisplayMouseModeY;
        DisplayXY[DisplayMsSpeed].X = DisplayMsSpeedX;
        DisplayXY[DisplayMsSpeed].Y = DisplayMsSpeedY;
        DisplayXY[DisplayGuideSpeed].X = DisplayGuideX;
        DisplayXY[DisplayGuideSpeed].Y = DisplayGuideY;
        DisplayXY[DisplayDateTime].X = DisplayDateTimeX;
        DisplayXY[DisplayDateTime].Y = DisplayDateTimeY;
        DisplayXY[DisplayFocusFast].X = DisplayFocusFastX;
        DisplayXY[DisplayFocusFast].Y = DisplayFocusY;
        DisplayXY[DisplayFocusSlow].X = DisplayFocusSlowX;
        DisplayXY[DisplayFocusSlow].Y = DisplayFocusY;
        DisplayXY[DisplayFRFocusAuxAction].X = DisplayFRFocusAuxActionX;
        DisplayXY[DisplayFRFocusAuxAction].Y = DisplayFocusY;
        DisplayXY[DisplayTrackByRate].X = MenuStartX;
        DisplayXY[DisplayTrackByRate].Y = DisplayLine1Y;
        DisplayXY[DisplayGEMFlipMove].X = MenuStartX;
        DisplayXY[DisplayGEMFlipMove].Y = DisplayLine1Y;
        DisplayXY[DisplayAccumGuide].X = DisplayAccumGuideX;
        DisplayXY[DisplayAccumGuide].Y = DisplayLine1Y;
        DisplayXY[DisplayPWMReps].X = DisplayPWMX;
        DisplayXY[DisplayPWMReps].Y = DisplayPWMY;
        DisplayXY[DisplayMsStatus].X = DisplayMsStatusX;
        DisplayXY[DisplayMsStatus].Y = DisplayMsStatusY;
        DisplayXY[DisplayQSC].X = DisplayQSCX;
        DisplayXY[DisplayQSC].Y = DisplayQSCY;
        DisplayXY[DisplayPEC].X = DisplayPECX;
        DisplayXY[DisplayPEC].Y = DisplayPECY;
        DisplayXY[DisplayAltAzEC].X = DisplayAltAzECX;
        DisplayXY[DisplayAltAzEC].Y = DisplayAltAzECY;
        DisplayXY[DisplayAltAltEC].X = DisplayAltAltECX;
        DisplayXY[DisplayAltAltEC].Y = DisplayAltAltECY;
        DisplayXY[DisplayAzAzEC].X = DisplayAzAzECX;
        DisplayXY[DisplayAzAzEC].Y = DisplayAzAzECY;
        DisplayXY[DisplayPMC].X = DisplayPMCX;
        DisplayXY[DisplayPMC].Y = DisplayPMCY;
        DisplayXY[DisplayHsSlew].X = DisplaySlewX;
        DisplayXY[DisplayHsSlew].Y = DisplaySlewY;
        DisplayXY[DisplayHsAbort].X = DisplaySlewX+6;
        DisplayXY[DisplayHsAbort].Y = DisplaySlewY;
        DisplayXY[DisplayHsSteps].X = DisplaySlewX+17;
        DisplayXY[DisplayHsSteps].Y = DisplaySlewY;
        DisplayXY[DisplayLX200].X = DisplayLX200X;
        DisplayXY[DisplayLX200].Y = DisplayLX200Y;
        DisplayXY[DisplayLX200_2].X = DisplayLX200X2;
        DisplayXY[DisplayLX200_2].Y = DisplayLX200Y2;
}

void BuildHotkeyStrings( void)
{
        HotkeyAmp = "restart scroll tour";
        HotkeyAt = "toggle right handpad mode to reset equatorial in grand tour";
        HotkeyRight = "simulate handpad mode switch move to the right";
        HotkeyLeft = "simulate handpad mode switch move to the left";
        HotkeyQmark = "enter new input equatorial coordinates";
        HotkeyGEMFlip = "do a manual GEM meridian flip";
        HotkeyStar = "do a three star polar alignment";
        HotkeyPercent = "zero out backlash";
        Hotkey1 = "move to input equatorial coordinates";
        Hotkey2 = "toggle tracking on and off";
        Hotkey3 = "save current equatorial coordinates into #1 buffer";
        Hotkey4 = "restore saved #1 equatorial coordinates into input fields";
        Hotkey5 = "save current equatorial coordinates into #2 buffer";
        Hotkey6 = "restore saved #2 equatorial coordinates into input fields";
        Hotkey7 = "read a slew file created by an external program";
        Hotkey8 = "write a slew file for use by an external program";
        Hotkey9 = "enter new input altazimuth coordinates";
        Hotkey0 = "reset to input altazimuth coordinates";
        Hotkeya = "calc. altitude offset Z3 using init #1 #2 = then re-init";
        Hotkeyc = "display working PEC in memory";
        Hotkeyd = "select an object from a data file";
        Hotkeyg = "call DOS version of Project Pluto Guide";
        Hotkeyh = "cycle through hand paddle mode settings";
        HotkeyH = "select a hand paddle mode";
        Hotkeyi = "display the initialization settings";
        Hotkeyl = "reload PEC from PECFile";
        Hotkeym = "set the microstepping speed";
        Hotkeyn = "move to input altazimuth coordinates";
        Hotkeyo = "restore last object selected from the data files";
        Hotkeyp = "toggle periodic error correction on and off";
        Hotkeyq = "quit the program";
        Hotkeyr = "reset to input equatorial coordinates";
        Hotkeys = "load a file of slow smooth scrolling motions";
        Hotkeyu = "extract altitude/declination PEC data from guiding efforts";
        Hotkeyv = "extract azimuth/right ascension PEC data from guiding efforts";
}

void DisplayHotkeyFile( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "& : ");
        strcat( StrBuf, HotkeyAmp);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "@ : ");
        strcat( StrBuf, HotkeyAt);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "7 : ");
        strcat( StrBuf, Hotkey7);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "8 : ");
        strcat( StrBuf, Hotkey8);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "b : begin scrolling");
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "d : ");
        strcat( StrBuf, Hotkeyd);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "g : or ` (left apostrophe) : ");
        strcat( StrBuf, Hotkeyg);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "q : ");
        strcat( StrBuf, Hotkeyq);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "s : ");
        strcat( StrBuf, Hotkeys);
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyMotor( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "2 : or t : ");
        strcat( StrBuf, Hotkey2);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "m : ");
        strcat( StrBuf, Hotkeym);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "microstepping : F1-up, F2-down, F3-CCW, F4-CW");
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "% : ");
        strcat( StrBuf, HotkeyPercent);
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyHandpad( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "> : ");
        strcat( StrBuf, HotkeyRight);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "< : ");
        strcat( StrBuf, HotkeyLeft);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "h : ");
        strcat( StrBuf, Hotkeyh);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "H : ");
        strcat( StrBuf, HotkeyH);
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyEC( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "c : ");
        strcat( StrBuf, Hotkeyc);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "e : average altitude/declination PEC files");
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "f : average azimuth/right ascension PEC files");
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "l : ");
        strcat( StrBuf, Hotkeyl);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "p : ");
        strcat( StrBuf, Hotkeyp);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "u : ");
        strcat( StrBuf, Hotkeyu);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "v : ");
        strcat( StrBuf, Hotkeyv);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "y : zero out altitude/declination PEC");
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "z : zero out azimuth/right ascension PEC");
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyInit( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "* : ");
        strcat( StrBuf, HotkeyStar);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "a : ");
        strcat( StrBuf, Hotkeya);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "i : ");
        strcat( StrBuf, Hotkeyi);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "k : kill all initializations");
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyCoord( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "? : ");
        strcat( StrBuf, HotkeyQmark);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "3 : ");
        strcat( StrBuf, Hotkey3);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "4 : ");
        strcat( StrBuf, Hotkey4);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "5 : ");
        strcat( StrBuf, Hotkey5);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "6 : ");
        strcat( StrBuf, Hotkey6);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "9 : ");
        strcat( StrBuf, Hotkey9);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "o : ");
        strcat( StrBuf, Hotkeyo);
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyMove( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "1 : ");
        strcat( StrBuf, Hotkey1);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "n : ");
        strcat( StrBuf, Hotkeyn);
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyReset( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "$ or [ or { : ");
        strcat( StrBuf, HotkeyGEMFlip);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "o : ");
        strcat( StrBuf, Hotkeyo);
        WriteStrBufToScreen_f_ptr();
        HoldXY.Y++;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "r : ");
        strcat( StrBuf, Hotkeyr);
        WriteStrBufToScreen_f_ptr();
}

void DisplayHotkeyTest( void)
{
        struct XY HoldXY;

        HoldXY.X = HotkeyFrame.Left+1;
        HoldXY.Y = HotkeyFrame.Top+2;
        VidMemXY = HoldXY;
        sprintf( StrBuf, "No TEST Hotkeys");
        WriteStrBufToScreen_f_ptr();
}

void CalcHsMsgSteps( void)
{
        double MaxHsRad;

        /* set halfsteps to move that triggers confirming msg */
        if( HsRad.A > HsRad.Z)
                MaxHsRad = HsRad.A;
        else
                MaxHsRad = HsRad.Z;
        MoveHsMsgSteps = (long) (MoveHsMsgDeg*DegToRad/MaxHsRad);
}

void CloseKBEvent( void)
{
        LX200ComPort = HoldLX200ComPort;
        fclose( OutGuideFilePtr);
        FreeAllScroll();
        clrscr();
        _setcursortype( _NORMALCURSOR);
        if( DisplayOpeningMsgs)
        {
                printf( "\nPlease turn off motor power supply.\n");
                ContMsgRoutine();
        }
}

void PrelimMsg( void)
{
        printf( "\nWarning: to prevent overheating motors & electronics, ");
        printf( "\n         turn off the motor power supply if program not running");
        printf( "\n         and stop tracking before hot-keying to another program.");
        printf( "\nPlease turn on the motors' power supply now.");
        NewLine;
        TurnOnMotorsSnd();
        ContMsgRoutine();
}

void TurnOnMotorsSnd( void)
{
        /* sound message to turn motors on */
        /* long lf beep, short hf beep */
        sound(1000);
        delay(300);
        sound(2000);
        delay(100);
        nosound();
}

/* clears menu category and menu subtitle area */
void ClearMenuArea( void)
{
        window( 2, MenuCatsY+1, MaxX-1, MenuDescY+1);
        Clrscr();
        window( 1, 1, MaxX, MaxY);
}

/* clears only menu subtitle area */
void ClearMenuSubArea( void)
{
        window( 2, MenuSubMenuY+1, MaxX-1, MenuDescY+1);
        Clrscr();
        window( 1, 1, MaxX, MaxY);
}

void DrawScreenLine( const int Y)
{
        TextAttr = BorderText;
        VidMemXY.Y = Y;
        for( VidMemXY.X = 1; VidMemXY.X < MaxX-1; VidMemXY.X++)
                WriteCharToScreen( HorizBorder);
        VidMemXY.X = 0;
        WriteCharToScreen( LeftIntersect);
        VidMemXY.X = MaxX-1;
        WriteCharToScreen( RightIntersect);
}

void WriteMainMenu( void)
{
        ClearMenuArea();
        WriteMenuCats();
        SelectTextAttrMenuCat( CurrentMenuCat);
        WriteSubMenus();
        SelectTextAttrMenuSub( CurrentMenuSub);
        WriteSubMenuDesc( CurrentMenuCat, CurrentMenuSub);
        /* draw a line separating the menu category from the menu subtitle area */
        DrawScreenLine( MenuSubLine1Y);
        /* draw a line separating the menu subtitle area from the menu description */
        DrawScreenLine( MenuSubLine2Y);
}

void WriteMenuCats( void)
{
        TextAttr = DefaultText;
        VidMemXY.Y = MenuCatsY;
        for( Ix = 0; Ix < MaxMenuCats; Ix++)
        {
                sprintf( StrBuf, "%s", MenuArray[Ix].Title);
                VidMemXY.X = MenuCatX[Ix];
                WriteStrBufToScreen_f_ptr();
        }
}

void SelectTextAttrMenuCat( const int MenuCat)
{
        TextAttr = SelectText;
        ChangeTextAttrMenuCat( MenuCat);
}

void DefaultTextAttrMenuCat( const int MenuCat)
{
        TextAttr = DefaultText;
        ChangeTextAttrMenuCat( MenuCat);
}

/* changes the attributes of the displayed text */
void ChangeTextAttrMenuCat( const int MenuCat)
{
        int StartX, EndX;

        VidMemXY.Y = MenuCatsY;
        StartX = MenuCatX[MenuCat];
        if( MenuCat+1 == MaxMenuCats)
                EndX = MenuEndX;
        else
                EndX = MenuCatX[MenuCat+1]-1;
        for( VidMemXY.X = StartX; VidMemXY.X < EndX;    VidMemXY.X++)
                Screen[VidMemXY.Y][VidMemXY.X].Attr = TextAttr;
}

void WriteSubMenus( void)
{
        TextAttr = MenuText;
        for( Ix = 0; Ix < MenuArray[CurrentMenuCat].NumSubTitles; Ix++)
        {
                TextAttr = MenuText;
                VidMemXY.Y = MenuSubMenuY + Ix%MaxMenuDisplayRows;
                VidMemXY.X = MenuSubX[Ix/MaxMenuDisplayRows];
                sprintf( StrBuf, "%s", MenuArray[CurrentMenuCat].SubTitles[Ix].Title);
                WriteStrBufToScreen_f_ptr();
        }
}

void WriteSubMenuDesc( const int MenuCat, const int SubMenu)
{
        TextAttr = DefaultText;
        VidMemXY.Y = MenuDescY;
        for( VidMemXY.X = MenuStartX; VidMemXY.X < MenuEndX; VidMemXY.X++)
                WriteCharToScreen( Blank);
        VidMemXY.X = MenuStartX;
        sprintf( StrBuf, "-> ");
        WriteStrBufToScreen_f_ptr();
        sprintf( StrBuf, "%s", MenuArray[MenuCat].SubTitles[SubMenu].Desc);
        WriteStrBufToScreen_f_ptr();
}

void SelectTextAttrMenuSub( const int MenuSub)
{
        TextAttr = SelectText;
        ChangeTextAttrMenuSub( MenuSub);
}

void MenuTextAttrMenuSub( const int MenuSub)
{
        TextAttr = MenuText;
        ChangeTextAttrMenuSub( MenuSub);
}

/* changes the attributes of the displayed text */
void ChangeTextAttrMenuSub( const int MenuSub)
{
        int StartX, EndX;

        VidMemXY.Y = MenuSubMenuY + MenuSub%MaxMenuDisplayRows;
        StartX = MenuSubX[MenuSub/MaxMenuDisplayRows];
        EndX = StartX + (MenuEndX - MenuStartX) / MaxMenuSubs - 1;
        for( VidMemXY.X = StartX; VidMemXY.X < EndX;    VidMemXY.X++)
                Screen[VidMemXY.Y][VidMemXY.X].Attr = TextAttr;
}

void UpdateMenuCatSub( void)
{
        /* new menu category and therefore new menu subtitle of that category */
        if( NewMenuCat != CurrentMenuCat)
        {
                DefaultTextAttrMenuCat( CurrentMenuCat);
                SelectTextAttrMenuCat( NewMenuCat);
                CurrentMenuCat = NewMenuCat;
                ClearMenuSubArea();
                WriteSubMenus();
                SelectTextAttrMenuSub( NewMenuSub);
                WriteSubMenuDesc( CurrentMenuCat, NewMenuSub);
                CurrentMenuSub = NewMenuSub;
        }
        else
                /* same menu category but new menu subtitle of that category */
                if( NewMenuSub != CurrentMenuSub)
                {
                        MenuTextAttrMenuSub( CurrentMenuSub);
                        SelectTextAttrMenuSub( NewMenuSub);
                        WriteSubMenuDesc( CurrentMenuCat, NewMenuSub);
                        CurrentMenuSub = NewMenuSub;
                }
}

/* draws border around inside edge of window */
void DrawBorder( const struct Frame P)
{
        TextAttr = BorderText;
        /* write top */
        VidMemXY.Y = P.Top - 1;
        for( VidMemXY.X = P.Left; VidMemXY.X < P.Right-1; VidMemXY.X++)
                WriteCharToScreen( HorizBorder);
        /* write bottom */
        VidMemXY.Y = P.Bottom - 1;
        for( VidMemXY.X = P.Left; VidMemXY.X < P.Right-1; VidMemXY.X++)
                WriteCharToScreen( HorizBorder);
        /* write left */
        VidMemXY.X = P.Left - 1;
        for( VidMemXY.Y = P.Top; VidMemXY.Y < P.Bottom-1; VidMemXY.Y++)
                WriteCharToScreen( VertBorder);
        /* write right */
        VidMemXY.X = P.Right - 1;
        for( VidMemXY.Y = P.Top; VidMemXY.Y < P.Bottom-1; VidMemXY.Y++)
                WriteCharToScreen( VertBorder);
        /* write corners */
        VidMemXY.X = P.Left - 1;
        VidMemXY.Y = P.Top - 1;
        WriteCharToScreen( TopLeftCorner);
        VidMemXY.X = P.Right - 1;
        WriteCharToScreen( TopRightCorner);
        VidMemXY.Y = P.Bottom - 1;
        WriteCharToScreen( BottomRightCorner);
        VidMemXY.X = P.Left - 1;
        WriteCharToScreen( BottomLeftCorner);

        /* write title */
        TextAttr = TitleText;
        VidMemXY.X = (P.Left + P.Right + 1)/2 - strlen( P.Title)/2 - 1;
        VidMemXY.Y = P.Top - 1;
        sprintf( StrBuf, "%s", P.Title);
        WriteStrBufToScreen_f_ptr();
}

void WriteWindow( struct Frame P)
{
        gettext( P.Left, P.Top, P.Right, P.Bottom, WinBuffer);
        window( P.Left, P.Top, P.Right, P.Bottom);
        Clrscr();
        window( 1, 1, MaxX, MaxY);
        DrawBorder( P);
        _setcursortype( _NORMALCURSOR);
}

void RemoveWindow( struct Frame P)
{
        puttext( P.Left, P.Top, P.Right, P.Bottom, WinBuffer);
        _setcursortype( _NOCURSOR);
}

/* after keyboard key is pressed, waits until next clock tick */
void PressKeyToContMsg( const char* Msg)
{
        WriteWindow( MsgFrame);
        gotoxy( MsgFrame.Left + 2, MsgFrame.Top + 2);
        printf( "%s", Msg);
        sound( 500);
        delay( 100);
        nosound();
        gotoxy( MsgFrame.Left + 2, MsgFrame.Top + 4);
        ContMsgRoutine();
        RemoveWindow( MsgFrame);
        PauseUntilNewSidTime();
        HPEventGetEquat();
}

void SetNewMenuCatSub( void)
{
        switch( Response)
        {
                case DownCursor:
                        NewMenuSub = CurrentMenuSub + 1;
                        if( NewMenuSub == MenuArray[CurrentMenuCat].NumSubTitles)
                                NewMenuSub = 0;
                        break;
                case UpCursor:
                        NewMenuSub = CurrentMenuSub - 1;
                        if( NewMenuSub < 0)
                                NewMenuSub = MenuArray[CurrentMenuCat].NumSubTitles - 1;
                        break;
                case RightCursor:
                case Tab:
                        NewMenuCat = CurrentMenuCat + 1;
                        if( NewMenuCat == MaxMenuCats)
                                NewMenuCat = 0;
                        NewMenuSub = 0;
                        break;
                case LeftCursor:
                case Shift_Tab:
                        NewMenuCat = CurrentMenuCat - 1;
                        if( NewMenuCat < 0)
                                NewMenuCat = MaxMenuCats - 1;
                        NewMenuSub = 0;
        }
}

void GetNewMenuCatSubFromResponse( void)
{
        NewMenuCat = NewMenuSub = 0;

        while( Response != MenuArray[NewMenuCat].SubTitles[NewMenuSub].MenuItem)
        {
                NewMenuSub++;
                /* not == MaxMenuSub */
                if( NewMenuSub == MenuArray[NewMenuCat].NumSubTitles)
                {
                        NewMenuSub = 0;
                        NewMenuCat++;
                        if( NewMenuCat == MaxMenuCats)
                                BadExit( "couldn't match Response in GetNewMenuCatSubFromResponse()");
                }
        }
}

/* Keyboard events checked every bios clock tick */
void ProcessKBEvents( void)
{


        Response = getch();

        /* any key press will restore normal screen updating */
        if( JumboDisplayFlag)
        {
                clrscr();
                puttext( 1, 1, MaxX, MaxY, WinBuffer);
                JumboDisplayFlag = No;
        }
        WriteCharToScreen_f_ptr = WriteCharToScreen;
        WriteStrBufToScreen_f_ptr = WriteStrBufToScreen;

        /* handle response based on which menu is active and displayed */
        if( MsParmsAllowedFlag)
        {
                ProcessMsParmsResponse();
                /* quitting tracking at constant rate of speed only mode */
                if( !MsParmsAllowedFlag)
                {
                        WriteMainMenu();
                        TrackByRateFlag = No;
                        WriteTrackByRate();
                }
        }
        else
                ProcessMenuResponse();
}

void ProcessVirtualHandpad( void)
{
        struct AZLongV HoldSteps;

        Steps.A = Steps.Z = 0;

        switch( Response)
        {
                case F1:
                        Steps.A = MsTick.A;
                        Dir.A = CW;
                        break;
                case F2:
                        Steps.A = MsTick.A;
                        Dir.A = CCW;
                        break;
                case F3:
                        Steps.Z = MsTick.Z;
                        Dir.Z = CCW;
                        break;
                case F4:
                        Steps.Z = MsTick.Z;
                        Dir.Z = CW;
        }
        HoldSteps = Steps;
        while( True)
        {
                HPEventMoveMs();
                HPEventGetEquat();
                CheckLX200Events();
                SequentialTaskController();
                /* add undone steps to steps to do for next clock tick */
                Steps.A += HoldSteps.A;
                Steps.Z += HoldSteps.Z;
                if( KeyStroke)
                        getch();
                else
                        break;
        }
        while( KeyStroke)
                getch();
        AlignMs_f_ptr();
        SetCurrentAltazToAccumMs();
        HPEventGetEquat();
}

void ProcessMenuResponse( void)
{
        int NewResponse;

        switch( Response)
        {
                /* here each case ends in a break: these are responses that do not involve menu item selection
                processing by ProcessMenuSelection() */
                case Tab:
                        SetNewMenuCatSub();
                        UpdateMenuCatSub();
                        ProcessHPEvents();
                        break;
                case ExtendedKeyboardStroke:
                        Response = getch();
                        if( Response == F1 || Response == F2 || Response == F3 || Response == F4)
                                ProcessVirtualHandpad();
                        else
                                if( Response == DownCursor || Response == UpCursor      || Response == RightCursor || Response == LeftCursor
                                || Response == Shift_Tab)
                                {
                                        SetNewMenuCatSub();
                                        UpdateMenuCatSub();
                                }
                                else
                                        if( Response == F5 || Response == F6 )
                                                if( FocusMethod == FocusMethod_Pulse_1_14 || FocusMethod == FocusMethod_Pulse_16_17)
                                                        ProcessKBMoveFocus();
                                                else
                                                        PressKeyToContMsg( "Not appropriate FocusMethod");
                                        else
                                                if( Response == F9)
                                                        if( HotkeyF9Set)
                                                        {
                                                                Response = HotkeyF9;
                                                                GetNewMenuCatSubFromResponse();
                                                                UpdateMenuCatSub();
                                                                ProcessMenuSelection();
                                                        }
                                                        else
                                                                PressKeyToContMsg( "nothing defined for hotkey F9");
                                                else
                                                        if( Response == F10)
                                                                if( HotkeyF10Set)
                                                                {
                                                                        Response = HotkeyF10;
                                                                        GetNewMenuCatSubFromResponse();
                                                                        UpdateMenuCatSub();
                                                                        ProcessMenuSelection();
                                                                }
                                                                else
                                                                        PressKeyToContMsg( "nothing defined for hotkey F10");
                                                        else
                                                                if( Response == F11)
                                                                        if( HotkeyF11Set)
                                                                        {
                                                                                Response = HotkeyF11;
                                                                                GetNewMenuCatSubFromResponse();
                                                                                UpdateMenuCatSub();
                                                                                ProcessMenuSelection();
                                                                        }
                                                                        else
                                                                                PressKeyToContMsg( "nothing defined for hotkey F11");
                                                                else
                                                                        if( Response == F12)
                                                                                if( HotkeyF12Set)
                                                                                {
                                                                                        Response = HotkeyF12;
                                                                                        GetNewMenuCatSubFromResponse();
                                                                                        UpdateMenuCatSub();
                                                                                        ProcessMenuSelection();
                                                                                }
                                                                                else
                                                                                        PressKeyToContMsg( "nothing defined for hotkey F12");

                                ProcessHPEvents();
                        break;
                /* the following case statements that end with a break have no corresponding menu option */
                case '@':
                        ToggleGrandTourRightKey();
                        break;
                case '&':
                        RestartScroll();
                        break;
                case 'b': case 'B':
                        ScrollFlag = Yes;
                        CurrentScrollCount = 0;
                        CurrentScroll = NULL;
                        break;
                case 'e': case 'E':
                        if( !AveragePECAnalysisFiles( altaxis))
                                PressKeyToContMsg( "no pecalt**.txt files found");
                        break;
                case 'f': case 'F':
                        if( !AveragePECAnalysisFiles( azaxis))
                                PressKeyToContMsg( "no pecaz**.txt files found");
                        break;
                case 'k': case 'K':
                        KillInits();
                        break;
                case 'y': case 'Y':
                        ZeroAltPEC();
                        PressKeyToContMsg( "Zeroed out Altitude PEC");
                        break;
                case 'z': case 'Z':
                        ZeroAzPEC();
                        PressKeyToContMsg( "Zeroed out Azimuth PEC");
                        break;
                case '*':
                        switch (PolarAlignmentStage)
                        {
                                case 0:
                                        ProcessPolarAlign0();
                                        break;
                                case 1:
                                        ProcessPolarAlign1();
                                        break;
                                case 2:
                                        ProcessPolarAlign2();
                                        break;
                                case 3:
                                        ProcessPolarAlign3();
                                        break;
                                case 4:
                                        ProcessPolarAlign4();
                                        break;
                        }
                        break;
                case Return:
                        Response = MenuArray[CurrentMenuCat].SubTitles[CurrentMenuSub].MenuItem;
                        ProcessMenuSelection();
                        break;
                /* no breaks so as to fall through */
                /* use NewResponse to hold menu choice, since using Response will set Response to a new value,
                yet Response must be kept unchanged for the case statements to work */
                case Left_Apostrophe:
                        if( Response == Left_Apostrophe)
                                NewResponse = MenuGuide;
                case '[':
                case '{':
                case '$':
                        if( Response == '[' || Response == '{' || Response == '$')
                                NewResponse = MenuGEMMeridianFlip;
                case '%':
                        if( Response == '%')
                                NewResponse = MenuZeroBacklash;
                case '?':
                        if( Response == '?')
                                NewResponse = MenuInputEquat;
                case '<':
                        if( Response == '<')
                                NewResponse = MenuHandpadLeft;
                case '>':
                        if( Response == '>')
                                NewResponse = MenuHandpadRight;
                case '1':
                        if( Response == '1')
                                NewResponse = MenuMoveEquat;
                case '2':
                        if( Response == '2')
                                NewResponse = MenuTrack;
                case '3':
                        if( Response == '3')
                                NewResponse = MenuSav1;
                case '4':
                        if( Response == '4')
                                NewResponse = MenuRes1;
                case '5':
                        if( Response == '5')
                                NewResponse = MenuSav2;
                case '6':
                        if( Response == '6')
                                NewResponse = MenuRes2;
                case '7':
                        if( Response == '7')
                                NewResponse = MenuReadSlew;
                case '8':
                        if( Response == '8')
                                NewResponse = MenuWriteSlew;
                case '9':
                        if( Response == '9')
                                NewResponse = MenuInputAltaz;
                case '0':
                        if( Response == '0')
                                NewResponse = MenuResetAltaz;
                case 'a': case 'A':
                        if( Response == 'a' || Response == 'A')
                                NewResponse = MenuAltOffset;
                case 'c': case 'C':
                        if( Response == 'c' || Response == 'C')
                                NewResponse = MenuPECDisplay;
                case 'd': case 'D':
                        if( Response == 'd' || Response == 'D')
                                NewResponse = MenuDataFile;
                case 'g': case 'G':
                        if( Response == 'g' || Response == 'G')
                                NewResponse = MenuGuide;
                case 'h':
                        if( Response == 'h')
                                NewResponse = MenuHandpad;
                case 'H':
                        if( Response == 'H')
                                NewResponse = MenuSelectHandpadMode;
                case 'i': case 'I':
                        if( Response == 'i' || Response == 'I')
                                NewResponse = MenuDisplayInit;
                case 'l': case 'L':
                        if( Response == 'l' || Response == 'L')
                                NewResponse = MenuPECReload;
                case 'm': case 'M':
                        if( Response == 'm' || Response == 'M')
                                NewResponse = MenuMsSpeed;
                case 'n': case 'N':
                        if( Response == 'n' || Response == 'N')
                                NewResponse = MenuMoveAltaz;
                case 'o': case 'O':
                        if( Response == 'o' || Response == 'O')
                                NewResponse = MenuRestoreLastObject;
                case 'p': case 'P':
                        if( Response == 'p' || Response == 'P')
                                NewResponse = MenuPECOnOff;
                case 'q': case 'Q':
                        if( Response == 'q' || Response == 'Q')
                                NewResponse = MenuQuit;
                case 'r': case 'R':
                        if( Response == 'r' || Response == 'R')
                                NewResponse = MenuResetEquat;
                case 's': case 'S':
                        if( Response == 's' || Response == 'S')
                                NewResponse = MenuScrollTour;
                case 't': case 'T':
                        if( Response == 't' || Response == 'T')
                                NewResponse = MenuTrack;
                case 'u': case 'U':
                        if( Response == 'u' || Response == 'U')
                                NewResponse = MenuPECGuidingAltDisplay;
                case 'v': case 'V':
                        if( Response == 'v' || Response == 'V')
                                NewResponse = MenuPECGuidingAzDisplay;

                        /* all fall through to here... */
                        Response = NewResponse;
                        GetNewMenuCatSubFromResponse();
                        UpdateMenuCatSub();
                        ProcessMenuSelection();
                        break;
                default:
                        ProcessHPEvents();
        }
}

Flag ConfirmHsMove( void)
{
        struct AZDouble HoldAZ;
        double MaxMoveDeg;
        int X = MsgFrame.Left + 5;
        int Y = MsgFrame.Top + 2;

        if( !PolarAlignmentStage && (Steps.A > MoveHsMsgSteps || Steps.Z > MoveHsMsgSteps))
        {
                if( Steps.A > Steps.Z)
                        MaxMoveDeg = (double) Steps.A*HsRad.A*RadToDeg;
                else
                        MaxMoveDeg = (double) Steps.Z*HsRad.Z*RadToDeg;

                WriteWindow( MsgFrame);
                gotoxy( X, Y);
                printf( "Halfstep move of %3.0f deg, ", MaxMoveDeg);
                Y += 2;
                gotoxy( X, Y);
                HoldAZ.A = (double) Steps.A*HsRad.A;
                if( Dir.A == CCW)
                        HoldAZ.A = -HoldAZ.A;
                HoldAZ.A += Current.Alt;
                HoldAZ.Z = (double) Steps.Z*HsRad.Z;
                if( Dir.Z == CCW)
                        HoldAZ.Z = -HoldAZ.Z;
                HoldAZ.Z += Current.Az;
                if( HoldAZ.Z > OneRev)
                        HoldAZ.Z -= OneRev;
                if( HoldAZ.Z < 0)
                        HoldAZ.Z += OneRev;
                printf( "   destination alt = %2.0f, az = %3.0f", HoldAZ.A*RadToDeg, HoldAZ.Z*RadToDeg);
                Y += 2;
                gotoxy( X, Y);
                printf( "      Please confirm by pressing 'Y'");
                GetResponseWithLX200Check();
                RemoveWindow( MsgFrame);
                PauseUntilNewSidTime();
                if( Response == 'Y' || Response == 'y' || Response == Return || Response == '`')
                        return Yes;
                else
                        return No;
        }
        else
                return Yes;
}

/* see motors.c for calling functions */
void KBEventMoveHs( void)
{
        struct AZLongV HoldSteps;

        CheckLX200Events();
        /* any time slew is commanded, reset accumulated drift */
        ProcessMenuResetAccumDrift();
        /* AlignMs uses Steps */
        HoldSteps = Steps;
        CheckLX200Events();
        AlignMs_f_ptr();
        CheckLX200Events();
        Steps = HoldSteps;
        /* HsTimerFlag halfstep displays done in SequentialTaskController() which is called from
        MoveHsUsingIRQTimer() */
        if( !HsTimerFlag)
        {
                TextAttr = DisplayText;
                VidMemXY = DisplayXY[DisplayHsSlew];
                sprintf( StrBuf, "On ");
                WriteStrBufToScreen_f_ptr();
                DisplayButtonsStatus();
        }
        HPEventMoveHs();
        /* don't call HPEventGetEquat() at this point in case KBEventMoveHs() being called from
        SetDirDistanceStepsThenMove(): this changes Current.Ra, Dec when Current.Ra, Dec should stay
        unchanged so as to continue slewing or resume tracking to */
        CheckLX200Events();
        if( MoveToCurrentRaDecFlag && AbortState)
        {
                PauseUntilNewSidTime();
                HPEventGetEquat();
        }
        CheckLX200Events();
        if( !HsTimerFlag)
        {
                TextAttr = DisplayText;
                VidMemXY = DisplayXY[DisplayHsSlew];
                sprintf( StrBuf, "Off");
                WriteStrBufToScreen_f_ptr();
                DisplayButtonsStatus();
                if( AbortState)
                {
                        TextAttr = DisplayText;
                        VidMemXY = DisplayXY[DisplayHsAbort];
                        sprintf( StrBuf, "%s", AbortText[AbortState]);
                        WriteStrBufToScreen_f_ptr();
                }
        }
        /* read encoders at end of slew */
        if( EncoderState > NotInitialized)
        {
                QueryAndReadEncoders();
                if( EncoderState == Read)
                {
                        DisplayEncoderCounts();
                        CalcEncoderAZ();
                        DisplayEncoderAltaz();
                        SetEncoderThresholdFlag();
                        /* if encoder error threshold exceeded: */
                        if( EncoderThreshold)
                                ProcessBadEncoderThresholdSlew();
                }
                else
                        DisplayEncodersNotAvailable();
        }
}

void KBEventInitMatrix( const int Init)
{
        InitMatrix( Init);
        DisplayInitStatusOnScreen();
}

void DisplayJumboRa( struct Position* P)
{
        int d1, d2, d3, d4, d5, d6;
        int startx = 8;
        int starty = 1;
        int xsize = 6;
        int ysize = 8;
        int attr = CurrentColor << 4;

        d1 = P->RaHMSH.Hr/10;
        d2 = P->RaHMSH.Hr - d1*10;
        d3 = P->RaHMSH.Min/10;
        d4 = P->RaHMSH.Min - d3*10;
        d5 = P->RaHMSH.Sec/10;
        d6 = P->RaHMSH.Sec - d5*10;

        /* blank out any previous display of first number */
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d1, startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d2, startx, starty, xsize, ysize, attr);
        startx += xsize;
        DisplayColon( startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d3, startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d4, startx, starty, xsize, ysize, attr);
        startx += xsize;
        DisplayColon( startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d5, startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d6, startx, starty, xsize, ysize, attr);
}

void DisplayJumboDec( struct Position* P)
{
        int d1, d2, d3, d4, d5, d6;
        int startx = 2;
        int starty = 14;
        int xsize = 6;
        int ysize = 8;
        int attr = CurrentColor << 4;

        d1 = P->DecDMS.Deg/10;
        d2 = P->DecDMS.Deg - d1*10;
        d3 = P->DecDMS.Min/10;
        d4 = P->DecDMS.Min - d3*10;
        d5 = P->DecDMS.Sec/10;
        d6 = P->DecDMS.Sec - d5*10;

        /* blank out any previous display */
        DisplayNegSign( startx, starty, xsize, ysize, DefaultBackground<<4);
        if( P->Dec < 0)
                DisplayNegSign( startx, starty, xsize, ysize, attr);

        startx += xsize;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d1, startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d2, startx, starty, xsize, ysize, attr);
        startx += xsize;
        DisplayColon( startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d3, startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d4, startx, starty, xsize, ysize, attr);
        startx += xsize;
        DisplayColon( startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d5, startx, starty, xsize, ysize, attr);
        startx += xsize + 3;
        DisplayLargeNum( 8, startx, starty, xsize, ysize, DefaultBackground<<4);
        DisplayLargeNum( d6, startx, starty, xsize, ysize, attr);
}

/* ensure that the encoder read occurs in a timely fashion after then query: this prevents
situations where the query is executed, then the motors are microstepped for a long period of time,
then the encoders are read returning the encoder counts at the time of the query, consequently
causing a mismatch between the position as derived from the motors and the position as derived
from the encoders;
a task is executed, then the 'Task' variable is set to cause the next task to execute at
'NextTaskTime'; any call to the function before time >= NextTaskTime causes function to simply
return false */
Flag SequentialEncoderController( void)
{
        static double NextTaskTime;
        double TimeDiff;

        TextAttr = DisplayText;

        TimeDiff = Current.SidT - NextTaskTime;
        if( TimeDiff <= -OneRev)
                TimeDiff += OneRev;
        if( TimeDiff < 0)
                return False;
        else
        {
                switch( ETask)
                {
                        case 0:
                                if( EncoderState != ReadReady)
                                {
                                        QueryEncoders_f_ptr();
                                        /* wait SerialWriteDelayMs before reading results of encoder query */
                                        NextTaskTime = Current.SidT + SerialWriteDelayMs*MilliSecToRad;
                                }
                                break;
                        case 1:
                                if( EncoderState == ReadReady)
                                {
                                        ReadEncoders_f_ptr();
                                        if( EncoderState == Read)
                                        {
                                                DisplayEncoderCounts();
                                                CalcEncoderAZ();
                                                DisplayEncoderAltaz();
                                                if( SlewState == SlewDone)
                                                {
                                                        SetEncoderThresholdFlag();
                                                        if( EncoderThreshold)
                                                                ProcessBadEncoderThresholdTrack();
                                                }
                                        }
                                        else
                                                DisplayEncodersNotAvailable();
                                }
                                /* wait one second before querying again */
                                NextTaskTime = Current.SidT + SecToRad;
                                break;
                        default:
                                ETask = -1;
                }
                ETask++;
                return True;
        }
}

/* NextTaskTime not used here: the following tasks will execute sequentially without delay as this
function is repeatedly called */
void SequentialHiPriController( void)
{
        static double HoldRa, HoldDec = -9999;
        static double HoldFRMotorAngle;

        TextAttr = CurrentText;

        switch( HTask)
        {
                case 0:
                        DisplayButtonsStatus();
                        break;
                case 1:
                        DisplayFRFocusAuxActionStatus();
                        break;
                case 2:
                        if( SlewState != SlewDone)
                                /* if middle of slew, update Current.A, Z */
                                SetCurrentAltazToAccumMs();
                        VidMemXY = DisplayXY[DisplayCurrentAlt];
                        VidMemDeg( Current.Alt);
                        break;
                case 3:
                        /* previous case statement calls SetCurrentAltazToAccumMs() */
                        VidMemXY = DisplayXY[DisplayCurrentAz];
                        VidMemDeg( Current.Az);
                        break;
                case 4:
                        if( Two.Init)
                        {
                                if( SlewState != SlewDone)
                                {
                                        SlewCurrent = Current;
                                        SetCurrentToSlew = True;
                                        HPEventGetEquat();
                                }
                                else
                                        SetCurrentToSlew = False;
                                if( Current.Ra != HoldRa)
                                {
                                        if( JumboDisplayFlag)
                                        {
                                                GetHMSH( RadToHundSec*Current.Ra, &Current.RaHMSH);
                                                DisplayJumboRa( &Current);
                                        }
                                        else
                                        {
                                                VidMemXY = DisplayXY[DisplayCurrentRa];
                                                VidMemRaHMS( &Current);
                                        }
                                        HoldRa = Current.Ra;
                                        PUT_SCOPE;
                                }
                                if( SetCurrentToSlew)
                                        Current = SlewCurrent;
                                break;
                        }
                case 5:
                        if( Two.Init)
                        {
                                if( SlewState != SlewDone)
                                {
                                        SlewCurrent = Current;
                                        SetCurrentToSlew = True;
                                        HPEventGetEquat();
                                }
                                else
                                        SetCurrentToSlew = False;
                                if( Current.Dec != HoldDec)
                                {
                                        if( JumboDisplayFlag)
                                        {
                                                GetDMS( RadToArcsec*Current.Dec, &Current.DecDMS);
                                                DisplayJumboDec( &Current);
                                        }
                                        else
                                        {
                                                VidMemXY = DisplayXY[DisplayCurrentDec];
                                                VidMemDecDMS( &Current);
                                        }
                                        HoldDec = Current.Dec;
                                        PUT_SCOPE;
                                }
                                if( SetCurrentToSlew)
                                        Current = SlewCurrent;
                                break;
                        }
                case 6:
                        TextAttr = DisplayText;
                        if( Two.Init && FRStepSize > 0)
                        {
                                /* displays actual field rotation angle of the motor */
                                if( HoldFRMotorAngle != FRMotorAngle)
                                {
                                        HoldFRMotorAngle = FRMotorAngle;
                                        sprintf( StrBuf, "%6.2f", FRMotorAngle*RadToDeg);
                                        VidMemXY = DisplayXY[DisplayFRMotorAngle];
                                        WriteStrBufToScreen_f_ptr();
                                        sprintf( StrBuf, "%4d %2d", FRDiagPulseHighCW - FRDiagPulseHighCCW, FRDiagReset);
                                        VidMemXY = DisplayXY[DisplayFRMotorPulses];
                                        WriteStrBufToScreen_f_ptr();
                                }
                        }
                        break;
                default:
                        HTask = -1;
        }
        HTask++;
}

void SequentialLowPriController( void)
{
        static int HoldSlewState, HoldAbortState;

        TextAttr = DisplayText;

        switch( LTask)
        {
                case 0:
                        if( HsTimerFlag && (HoldSlewState != SlewState))
                        {
                                VidMemXY = DisplayXY[DisplayHsSlew];
                                sprintf( StrBuf, "%s", SlewText[SlewState]);
                                WriteStrBufToScreen_f_ptr();
                                HoldSlewState = SlewState;
                                break;
                        }
                case 1:
                        if( HsTimerFlag && (HoldAbortState != AbortState))
                        {
                                VidMemXY = DisplayXY[DisplayHsAbort];
                                sprintf( StrBuf, "%s", AbortText[AbortState]);
                                WriteStrBufToScreen_f_ptr();
                                HoldAbortState = AbortState;
                                break;
                        }
                case 2:
                        if( SlewState == SlewDone)
                        {
                                getdate( &d);
                                gettime( &t);
                                sprintf( StrBuf, "%2d/%02d %2d:%02d:%02d", d.da_mon, d.da_day, t.ti_hour, t.ti_min,
                                t.ti_sec);
                                VidMemXY = DisplayXY[DisplayDateTime];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 3:
                        if( HsTimerFlag && (SlewState != SlewDone))
                        {
                                VidMemXY = DisplayXY[DisplayHsSteps];

                                sprintf( StrBuf, "%12ld/%8ld/%8ld/%8ld/%8ld/%4d", RampHs, RampUpSteps, MaxSlewUpSteps,
                                MaxSlewDownSteps, RampDownSteps, HsRepsIx);

                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 4:
                        VidMemXY = DisplayXY[DisplaySidT];
                        VidMemSidT( &Current);
                        break;
                case 5:
                        if( RefractFlag)
                        {
                                CalcRefractScopeToSky( Current.Alt);
                                sprintf( StrBuf, "%5.3f", Refract*RadToDeg);
                        }
                        else
                                sprintf( StrBuf, "0");
                        VidMemXY = DisplayXY[DisplayRefract];
                        WriteStrBufToScreen_f_ptr();
                        break;
                case 6:
                        /* do CalcFieldR() here even though when tracking CalcFieldR() is called from MoveMs() */
                        if( Two.Init && FRStepSize == 0)
                        {
                                CalcFieldR();
                                break;
                        }
                case 7:
                        /* displays calculated current field rotation */
                        if( Two.Init)
                        {
                                sprintf( StrBuf, "%7.3f", FieldR*RadToDeg);
                                VidMemXY = DisplayXY[DisplayFR];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 8:
                        /* displays rate of field rotation */
                        if( Two.Init)
                        {
                                CalcFieldRate();
                                sprintf( StrBuf, "%5.2f", FieldRate);
                                VidMemXY = DisplayXY[DisplayFRRate];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 9:
                        /* displays calculated handpad guide button rotation angle */
                        if( Two.Init && FRStepSize > 0)
                        {
                                sprintf( StrBuf, "%6.2f", GuideFRAngle*RadToDeg);
                                VidMemXY = DisplayXY[DisplayFRGuideAngle];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 10:
                        if( Two.Init)
                        {
                                CalcAirMass();
                                sprintf( StrBuf, "%3.1f", AirMass);
                                VidMemXY = DisplayXY[DisplayAirMass];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 11:
                        if( Two.Init)
                        {
                                CalcDomeAzimuth();
                                sprintf( StrBuf, "%3.0f", DomeAzimuth*RadToDeg);
                                VidMemXY = DisplayXY[DisplayDomeAzimuth];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 12:
                        if( LX200ComPort && LX200DisplayFlag)
                        {
                                DisplayLX200CommandsAndCharBuffer();
                                break;
                        }
                case 13:
                        if( PECFlag)
                        {
                                DisplayAltPEC();
                                break;
                        }
                case 14:
                        if( PECFlag)
                        {
                                DisplayAzPEC();
                                break;
                        }
                case 15:
                        if( PointingModelFlag)
                        {
                                sprintf( StrBuf, "%3.2f %3.2f", PMC.A*RadToArcmin, PMC.Z*RadToArcmin);
                                VidMemXY = DisplayXY[DisplayPMC];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 16:
                        if( UseAltAzECFlag)
                        {
                                sprintf( StrBuf, "%3.2f", AltAzECRad*RadToArcmin);
                                VidMemXY = DisplayXY[DisplayAltAzEC];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 17:
                        if( UseAltAltECFlag)
                        {
                                sprintf( StrBuf, "%3.2f", AltAltECRad*RadToArcmin);
                                VidMemXY = DisplayXY[DisplayAltAltEC];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 18:
                        if( UseAzAzECFlag)
                        {
                                sprintf( StrBuf, "%3.2f", AzAzECRad*RadToArcmin);
                                VidMemXY = DisplayXY[DisplayAzAzEC];
                                WriteStrBufToScreen_f_ptr();
                                break;
                        }
                case 19:
                        if( UseQSC)
                        {
                                DisplayQSCvalues();
                                break;
                        }
                case 20:
                        if( GuideFlag)
                        {
                                WriteAccumGuide();
                                break;
                        }
                default:
                        LTask = -1;
        }
        LTask++;
}

void SequentialTaskController( void)
{
        static int HoldFocusPosition;
        static int HoldGEMflippedFlag;
        static int lastZ = 10;

        if ((Dir.Z != lastZ) && AzFullStepSizeArcsecCW && AzFullStepSizeArcsecCCW)
          {
            if (Dir.Z == CW)
              AzFullStepSizeArcsec = AzFullStepSizeArcsecCW;
            else
              AzFullStepSizeArcsec = AzFullStepSizeArcsecCCW;

            CalcVarsRelatingToStepSizes();
            CalcBacklashVars();
            CalcHsMsgSteps();
            SetAccumMsToCurrentAltaz();
            WriteMsArcsecSec();

            lastZ = Dir.Z;
          }

        TextAttr = DisplayText;

        /* start of tasks to be executed every time... */


        /* check for beeping indicating end of slew */
        CheckSlewBeep();
        /* fix current sidereal time if using IRQ8 method of timing interrupts, which disturbs the OS clock;
                update ActualBacklashRad */
        if( HsTimerFlag && SlewState != SlewDone)
        {
                disable();
                ElapsedHSSec = (double) timer_count / TIMER_FREQ;
                enable();
                Current.SidT = StartSidTHS + ElapsedHSSec * SecToRad;
                /* update ActualBacklashRad from ActualBacklashMs. values for proper Current. altaz coord displays */
                CalcActualBacklashRad();
        }
        /* detect gem flipped state */
        DetectGEMflippedFromCurrentAltaz();
        if( HoldGEMflippedFlag != GEMflippedFlag)
        {
                DisplayGEMFlipStatus();
                if( HandpadFlipUpDownWithGEMFlip)
                        if( GEMflippedFlag)
                                UpDownButtonsReversedFlag = True;
                        else
                                UpDownButtonsReversedFlag = False;
                HoldGEMflippedFlag = GEMflippedFlag;
        }
        /* add non-zero equatorial drift */
        if( Two.Init && DriftEquatFlag)
        {
                Current.Ra += DriftTick.Ra;
                Current.Dec += DriftTick.Dec;
        }
        /* display focus position every time for precise focusing to a particular position */
        if( (FocusMethod == FocusMethod_Pulse_1_14 || FocusMethod == FocusMethod_Pulse_16_17)
        && HoldFocusPosition != FocusPosition)
        {
                WriteFocusPosition();
                HoldFocusPosition = FocusPosition;
        }
        /* end of tasks to be executed every time... */

        /* now handle other tasks */
        /* only call encoders if slew is done */
        if( EncoderState > NotInitialized && SlewState == SlewDone && SequentialEncoderController())
                ;
        else
        {
                SequentialHiPriController();
                SequentialHiPriController();
                SequentialLowPriController();
        }
}

void CheckSlewBeep( void)
{
        if( SlewBeep == SlewBeepOn)
        {
                SlewBeep = SlewBeepOff;
                SlewBeepSound = 0;
                nosound();
        }
        else
                if( SlewBeep == SlewFinished)
                {
                        switch( SlewBeepSound)
                        {
                                case 0:
                                        SlewBeepSound = 1000;
                                        break;
                                case 1000:
                                        SlewBeepSound = 800;
                                        break;
                                case 800:
                                        SlewBeepSound = 600;
                                        break;
                                case 600:
                                        SlewBeepSound = 400;
                                        SlewBeep = SlewBeepOn;
                                        break;
                        }
                        sound( SlewBeepSound);
                }
}

void DisplayQSCvalues( void)
{
        TextAttr = DisplayText;
        VidMemXY = DisplayXY[DisplayQSC];
        /* display in decimal fullsteps */
        sprintf( StrBuf, " %.2f %.2f", QSC.A/(HsRad.A*2), QSC.Z/(HsRad.Z*2));
        /* display in arcseconds */
        /* sprintf( StrBuf, " %1.1f %1.1f", QSC.A*RadToArcsec, QSC.Z*RadToArcsec); */
        WriteStrBufToScreen_f_ptr();
}

void CalcGuideFRAngle( void)
{
        GuideFRAngle = ValidRad( FieldR - GuideFRAngleOffset);
}

void ClosestInit( void)
{
        struct Position ToTry, Temp;

        /* read through AnalysisFile */

        Input = fopen( AnalysisFile, "r");
        if( Input == NULL)
                printf( "\nDid not find %s", AnalysisFile);
        else
        {
                Temp = Current;
                while( !feof( Input))
                {
                        FReadPositionToNewLine( Input, &ToTry);
                        if( !feof( Input))
                                BubbleSortPositions( &ToTry);
                }
                fclose( Input);
                strcpy( WhyInit, WHY_INIT_OPTIMIZE);
                if( Three.Init)
                {
                        Current = Three;
                        KBEventInitMatrix( 3);
                }
                else
                {
                        Current = Two;
                        KBEventInitMatrix( 2);
                }
                Current = Temp;
        }
}

/* sorts Position, making 'A' the closest to Current */

void SortPosition( struct Position* A, struct Position* B, const double Diff)
{
        double InitADistance, InitBDistance;
        struct Position Temp;

        InitADistance = CalcEquatAngularSep( &Current, A);
        InitBDistance = CalcEquatAngularSep( &Current, B);
        if( InitADistance > InitBDistance + Diff)
        {
                Temp = *B;
                *B = *A;
                *A = Temp;
        }
}

/* bubble sort One, Two, (Three if ok), Temp, with One being the minimum distance from Current and
Temp being the maximum distance from Current */

void BubbleSortPositions( struct Position* Temp)
{
        Flag Duplicate = No;

        if( Temp->Ra == One.Ra && Temp->Dec == One.Dec && Temp->Alt == One.Alt && Temp->Az == One.Az &&
        Temp->SidT == One.SidT)
                Duplicate = Yes;
        if( Temp->Ra == Two.Ra && Temp->Dec == Two.Dec && Temp->Alt == Two.Alt && Temp->Az == Two.Az &&
        Temp->SidT == Two.SidT)
                Duplicate = Yes;
        if( Temp->Ra == Three.Ra && Temp->Dec == Three.Dec && Temp->Alt == Three.Alt &&
        Temp->Az == Three.Az && Temp->SidT == Three.SidT)
                Duplicate = Yes;

        if( !Duplicate)
        {
                if( !Three.Init)
                {
                        SortPosition( &One, &Two, ArcminToRad);
                        SortPosition( &Two, Temp, ArcminToRad);

                        SortPosition( &One, &Two, ArcminToRad);
                }
                else
                {
                        SortPosition( &One, &Two, ArcminToRad);
                        SortPosition( &Two, &Three, ArcminToRad);
                        SortPosition( &Three, Temp, ArcminToRad);

                        SortPosition( &One, &Two, ArcminToRad);
                        SortPosition( &Two, &Three, ArcminToRad);

                        SortPosition( &One, &Two, ArcminToRad);
                }
        }
}

Flag SafetyZoneConflict( void)
{
   if( SafetyZoneFlag)
   {
                // Following code covers case where Safety Zone is on east or west side of meridian
                if( (GEMflippedFlag && Current.Az > SafetyZoneOnLow && Current.Az < SafetyZoneOnHigh)
                                || (!GEMflippedFlag && Current.Az > SafetyZoneOffLow && Current.Az < SafetyZoneOffHigh))
                        return True;
                // Following code covers case where Safety Zone is on both sides of meridian
                if( AutoGEMFlipOnFuzzRad <= 0.0 && AutoGEMFlipOffFuzzRad < 0.0  && !GEMflippedFlag)
                        if( Current.Az > SafetyZoneOffLow && (Current.Az < OneRev || Current.Az > 0.0) && Current.Az < SafetyZoneOffHigh)
                                return True;
        }
        return False;
}

