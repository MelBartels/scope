/*
copyright 1990 through 2009 by Mel Bartels

         This file is part of scope.exe the stepper version.

         Scope.exe is free software; you can redistribute it and/or modify
         it under the terms of the GNU General Public License as published by
         the Free Software Foundation; either version 2 of the License, or
         (at your option) any later version.

         Scope.exe is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
         GNU General Public License for more details.

         You should have received a copy of the GNU General Public License
         along with scope.exe; if not, write to the Free Software
         Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <math.h>
#include <time.h>
#include <dos.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <values.h>
#include <string.h>
#include <ctype.h>
#include <dir.h>
#include <process.h>
#include <graphics.h>
#include "header.h"

/* config... */

void ReadConfig( void)
{
        char C;
        int I;
        char StrCompare[MaxStr];

        /* defaults */
        DefaultBackground = 0;
        DefaultColor = 7;
        TitleColor = 9;
        BorderColor = 1;
        MenuColor = 12;
        DisplayColor = 12;
        SelectColor = 0;
        CurrentColor = 14;
        SelectBackground = 4;
        ConfirmQuit = 0;
        DisplayOpeningMsgs = 1;
   HorizonLimitFlag = 0;
        MoveHsMsgDeg = 10;
        HotkeyF9 = HotkeyF10 = HotkeyF11 = HotkeyF12 = 0;
        HotkeyF9Set = HotkeyF10Set = HotkeyF11Set = HotkeyF12Set = False;
        InterfacePath = "C:\\GUIDE\\";
        UseMouseFlag = 0;
        IACA_Flag = 0;
   GEMFlipPossible = 0;
        AutoGEMFlip = 0;
        AutoGEMFlipOnFuzzDeg = 0;
        AutoGEMFlipOffFuzzDeg = 0;
        Siderostat = 0;
        HomeAltDeg = 0;
        HomeAzDeg = 0;
        MsArcsecSec = 300;
        precessionNutationAberration = 0;
        RefractFlag = 0;
        UseAltAzECFlag = 0;
        UseAltAltECFlag = 0;
        UseAzAzECFlag = 0;
        PointingModelFlag = 0;
        HandpadPresentFlag = 1;
        StartingHandpadMode = HandpadOff;
        HandpadDesign = StandardHandpad;
        UpDownButtonsReversedFlag = Off;
        HandpadFlipUpDownWithGEMFlip = Off;
        AltBacklashArcmin = 0;
        AzBacklashArcmin = 0;
        ABacklashSignalPPortPin17 = 0;
        AltLowLimitDeg = 0;
        AltHighLimitDeg = 0;
        AzLowLimitDeg = 0;
        AzHighLimitDeg = 0;
        GuideArcsecSec = 5;
        GuideDragAltArcsecPerMin = 10;
        GuideDragAzArcsecPerMin = 10;
        GuideDragRaArcsecPerMin = 10;
        GuideDragDecArcsecPerMin = 10;
        HPUpdateDriftFlag = Yes;
        DriftAltArcsecPerMin = 0;
        DriftAzArcsecPerMin = 0;
        DriftRaDegPerHr = 0;
        DriftDecDegPerHr = 0;
        PECFlag = 0;
        AutoAltPECPin = 17;
        AutoAltPECSyncOnFlag = 0;
        AutoAltPECSyncLowHighFlag = 1;
        AutoAltPECSyncDirFlag = 0;
        AutoAltPECDeBounce = 0;
        AutoAzPECPin = 15;
        AutoAzPECSyncOnFlag = 0;
        AutoAzPECSyncLowHighFlag = 1;
        AutoAzPECSyncDirFlag = 0;
        AutoAzPECDeBounce = 0;
        FullstepsPerPECArray = 200;
        PECIxOffset.A = 0;
        PECIxOffset.Z = 0;
        FRStepSizeArcsec = 60;
        SectoredFRDrive = 1;
        FRStepSpeedMilliSec = 20;
        ReverseFRMotor = 0;
        FocusMethod = 0;
        ReverseFocusMotor = 0;
        FocusFastStepsSec = 2;
        FocusSlowStepsSec = 1;
        FocusPosition = 0;
        MotorControlMethod = 0;
        MotorWindings = 4;
        InvertOutput = 1;
        KeepAlivePPortPin = 0;
        AltFullStepSizeArcsec = 3;
        AzFullStepSizeArcsec = 3;
		  AzFullStepSizeArcsecCW = 3;
		  AzFullStepSizeArcsecCCW = 3;
        ReverseAMotor = 0;
        ReverseZMotor = 0;
        HsRampStyle = 1;
        HsTimerFlag = 1;
        MaxDelay = 1000;
        MinDelay = 300;
        HsDelayX = 2;
        HsRampX = 5;
        InterruptHs = 100;
        HoldReps = 20;
        HsOverVoltageControl = 0;
        MaxConsecutiveSlews = 5;
        MsPowerDownSec = 5;
        PWMRepsTick = 35;
        AvgPWMRepsTickOnFlag = 1;
        MsDelayX = 6;
        MsPause = 500;
        Ms = 10;
        MaxIncrMsPerPWMWasRead = False;
        MsHsToggleIncrMsPerPWMWasRead = False;
        MaxPWM = 100;
        UseComplexPWMFlag = UseComplexPWMZFlag = No;
        /* zero out PWM[] arrays */
        for( Ix = 0; Ix < MaxMs; Ix++)
        {
                PWM[Ix].A = 0;
                PWM[Ix].Z = 0;
                PWMZ[Ix].A = 0;
                PWMZ[Ix].Z = 0;
        }
        PWM[0].A = 100;
        PWM[1].A = 100;
        PWM[2].A = 100;
        PWM[3].A = 100;
        PWM[4].A = 100;
        PWM[5].A = 100;
        PWM[6].A = 85;
        PWM[7].A = 70;
        PWM[8].A = 55;
        PWM[9].A = 35;
        UsePWMZFlag = No;
        SavePWMComp = No;
        /* 5 is max # of motor windings */
        for( Ix = 0; Ix < 5; Ix++)
                PWM_A_Comp[Ix] = PWM_Z_Comp[Ix] = 1.;
        UseQSC = No;
        for( Ix = 0; Ix < sizeofQSC; Ix++)
                QSCvalues[Ix].A = QSCvalues[Ix].Z = 0;
        PPortAddr = 1;
   // add a couple of default eyepieces: must be <= MAX_EYEPIECES
        Eyepieces = 2;
        EPFocusPosition[0].Position = 100;
        strcpy( EPFocusPosition[0].Name, "EyePiece20mm");
        EPFocusPosition[1].Position = 200;
        strcpy( EPFocusPosition[1].Name, "EyePiece9mm");
        CommPort[Com3].Base = 0x3E8;
        CommPort[Com4].Base = 0x2E8;
        CommPort[Com3].IRQ = 4;
        CommPort[Com4].IRQ = 3;
        EncoderString = "NoEncoders";
        EncoderComPort = 0;
        EncoderBaudRate = 9600;
        SerialWriteDelayMs = 50;
        AltEncoderCountsPerRev = 8192;
        AzEncoderCountsPerRev = 8192;
        AltEncoderDir = 1;
        AzEncoderDir = 0;
        EncoderErrorThresholdDeg = 0;
        TrackEncoderErrorThresholdDeg = 0;
        MakeEncoderResetLogFile = No;
        EncoderOffset.A = 0;
        EncoderOffset.Z = 0;
        LX200ComPort = 0;
        LX200BaudRate = 9600;
        LX200MotionTimeoutSec = 5;
        LX200SlewHs = 10000L;
        LX200_LongFormat = 0;
        Current.Alt = 0;
        Current.Az = 0;
        AccumMs.A = 0;
        AccumMs.Z = 0;
        StartInitState = 0;
        One.Init = No;
        Two.Init = No;
        Three.Init = No;
        Z1Deg = 0;
        Z2Deg = 0;
        Z3Deg = 0;
        DataFileCoordYear = 2000;
        LatitudeDeg = 44;
        CMOS_RTC_Access = 0;
        LongitudeDeg = 123;
   Height = 0;
        Tz = 8;
        DST = 1;
        TestString = "NoTest";

        MaxPWMFoundFlag = No;

        Input = fopen( ConfigFile, "r");
        if( Input == NULL)
                if( DisplayOpeningMsgs)
                {
                        printf( "Warning: no %s found, using default values.\n", ConfigFile);
                        ContMsgRoutine();
                }
                else
                        BadExit( strcat( "Could not open ", ConfigFile));
        else
                fscanf( Input, "%s", Name);

        while( Input!=NULL && !feof( Input))
        {
                /* if 1st char is ';' or '[' then goto next line */
                if( Name[0] == ';' || Name[0] == '[')
                        FReadToNewLine( Input);

                if( (strncmpi( Name, "DefaultBackground", sizeof( Name))) == 0)
                        FReadInt( Input, &DefaultBackground);
                if( (strncmpi( Name, "DefaultColor", sizeof( Name))) == 0)
                        FReadInt( Input, &DefaultColor);
                if( (strncmpi( Name, "TitleColor", sizeof( Name))) == 0)
                        FReadInt( Input, &TitleColor);
                if( (strncmpi( Name, "BorderColor", sizeof( Name))) == 0)
                        FReadInt( Input, &BorderColor);
                if( (strncmpi( Name, "MenuColor", sizeof( Name))) == 0)
                        FReadInt( Input, &MenuColor);
                if( (strncmpi( Name, "DisplayColor", sizeof( Name))) == 0)
                        FReadInt( Input, &DisplayColor);
                if( (strncmpi( Name, "SelectColor", sizeof( Name))) == 0)
                        FReadInt( Input, &SelectColor);
                if( (strncmpi( Name, "CurrentColor", sizeof( Name))) == 0)
                        FReadInt( Input, &CurrentColor);
                if( (strncmpi( Name, "SelectBackground", sizeof( Name))) == 0)
                        FReadInt( Input, &SelectBackground);
                if( (strncmpi( Name, "ConfirmQuit", sizeof( Name))) == 0)
                        FReadFlag( Input, &ConfirmQuit);
                if( (strncmpi( Name, "DisplayOpeningMsgs", sizeof( Name))) == 0)
                        FReadFlag( Input, &DisplayOpeningMsgs);
                if( (strncmpi( Name, "HorizonLimitFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &HorizonLimitFlag);
                if( (strncmpi( Name, "MoveHsMsgDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &MoveHsMsgDeg);
                if( (strncmpi( Name, "HotkeyF9", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &HotkeyF9);
                        HotkeyF9Set = True;
                }
                if( (strncmpi( Name, "HotkeyF10", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &HotkeyF10);
                        HotkeyF10Set = True;
                }
                if( (strncmpi( Name, "HotkeyF11", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &HotkeyF11);
                        HotkeyF11Set = True;
                }
                if( (strncmpi( Name, "HotkeyF12", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &HotkeyF12);
                        HotkeyF12Set = True;
                }
                if( (strncmpi( Name, "InterfacePath", sizeof( Name))) == 0)
                        FReadStringToCharCountOrNewLine( Input, InterfacePath, sizeof( Name));
                if( (strncmpi( Name, "UseMouseFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &UseMouseFlag);
                if( (strncmpi( Name, "IACA_Flag", sizeof( Name))) == 0)
                        FReadFlag( Input, &IACA_Flag);
                if( (strncmpi( Name, "GEMFlipPossible", sizeof( Name))) == 0)
                        FReadFlag( Input, &GEMFlipPossible);
                if( (strncmpi( Name, "AutoGEMFlip", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoGEMFlip);
                if( (strncmpi( Name, "AutoGEMFlipOnFuzzDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &AutoGEMFlipOnFuzzDeg);
                if( (strncmpi( Name, "AutoGEMFlipOffFuzzDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &AutoGEMFlipOffFuzzDeg);
                if( (strncmpi( Name, "Siderostat", sizeof( Name))) == 0)
                        FReadFlag( Input, &Siderostat);
                if( (strncmpi( Name, "HomeAltDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &HomeAltDeg);
                if( (strncmpi( Name, "HomeAzDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &HomeAzDeg);
                if( (strncmpi( Name, "MsArcsecSec", sizeof( Name))) == 0)
                        FReadInt( Input, &MsArcsecSec);
                if( (strncmpi( Name, "precessionNutationAberration", sizeof( Name))) == 0)
                        FReadFlag( Input, &precessionNutationAberration);
                if( (strncmpi( Name, "RefractFlag", sizeof( Name))) == 0)
                        FReadInt( Input, &RefractFlag);
                if( (strncmpi( Name, "UseAltAzECFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &UseAltAzECFlag);
                if( (strncmpi( Name, "UseAltAltECFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &UseAltAltECFlag);
                if( (strncmpi( Name, "UseAzAzECFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &UseAzAzECFlag);
                if( (strncmpi( Name, "PointingModelFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &PointingModelFlag);
                if( (strncmpi( Name, "HandpadPresentFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &HandpadPresentFlag);
                if( (strncmpi( Name, "StartingHandpadMode", sizeof( Name))) == 0)
                        FReadInt( Input, &StartingHandpadMode);
                if( (strncmpi( Name, "HandpadDesign", sizeof( Name))) == 0)
                        FReadInt( Input, &HandpadDesign);
                if( (strncmpi( Name, "UpDownButtonsReversedFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &UpDownButtonsReversedFlag);
                if( (strncmpi( Name, "HandpadFlipUpDownWithGEMFlip", sizeof( Name))) == 0)
                        FReadFlag( Input, &HandpadFlipUpDownWithGEMFlip);
                if( (strncmpi( Name, "AltBacklashArcmin", sizeof( Name))) == 0)
                        FReadDouble( Input, &AltBacklashArcmin);
                if( (strncmpi( Name, "AzBacklashArcmin", sizeof( Name))) == 0)
                        FReadDouble( Input, &AzBacklashArcmin);
                if( (strncmpi( Name, "ABacklashSignalPPortPin17", sizeof( Name))) == 0)
                        FReadFlag( Input, &ABacklashSignalPPortPin17);
                if( (strncmpi( Name, "AltLowLimitDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &AltLowLimitDeg);
                if( (strncmpi( Name, "AltHighLimitDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &AltHighLimitDeg);
                if( (strncmpi( Name, "AzLowLimitDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &AzLowLimitDeg);
                if( (strncmpi( Name, "AzHighLimitDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &AzHighLimitDeg);
                if( (strncmpi( Name, "GuideArcsecSec", sizeof( Name))) == 0)
                        FReadInt( Input, &GuideArcsecSec);
                if( (strncmpi( Name, "GuideDragAltArcsecPerMin", sizeof( Name))) == 0)
                        FReadDouble( Input, &GuideDragAltArcsecPerMin);
                if( (strncmpi( Name, "GuideDragAzArcsecPerMin", sizeof( Name))) == 0)
                        FReadDouble( Input, &GuideDragAzArcsecPerMin);
                if( (strncmpi( Name, "GuideDragRaArcsecPerMin", sizeof( Name))) == 0)
                        FReadDouble( Input, &GuideDragRaArcsecPerMin);
                if( (strncmpi( Name, "GuideDragDecArcsecPerMin", sizeof( Name))) == 0)
                        FReadDouble( Input, &GuideDragDecArcsecPerMin);
                if( (strncmpi( Name, "HPUpdateDriftFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &HPUpdateDriftFlag);
                if( (strncmpi( Name, "DriftAltArcsecPerMin", sizeof( Name))) == 0)
                        FReadDouble( Input, &DriftAltArcsecPerMin);
                if( (strncmpi( Name, "DriftAzArcsecPerMin", sizeof( Name))) == 0)
                        FReadDouble( Input, &DriftAzArcsecPerMin);
                if( (strncmpi( Name, "DriftRaDegPerHr", sizeof( Name))) == 0)
                        FReadDouble( Input, &DriftRaDegPerHr);
                if( (strncmpi( Name, "DriftDecDegPerHr", sizeof( Name))) == 0)
                        FReadDouble( Input, &DriftDecDegPerHr);
                if( (strncmpi( Name, "PECFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &PECFlag);
                if( (strncmpi( Name, "AutoAltPECPin", sizeof( Name))) == 0)
                        FReadLong( Input, &AutoAltPECPin);
                if( (strncmpi( Name, "AutoAltPECSyncOnFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAltPECSyncOnFlag);
                if( (strncmpi( Name, "AutoAltPECSyncLowHighFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAltPECSyncLowHighFlag);
                if( (strncmpi( Name, "AutoAltPECSyncDirFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAltPECSyncDirFlag);
                if( (strncmpi( Name, "AutoAltPECDeBounce", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAltPECDeBounce);
                if( (strncmpi( Name, "AutoAzPECPin", sizeof( Name))) == 0)
                        FReadLong( Input, &AutoAzPECPin);
                if( (strncmpi( Name, "AutoAzPECSyncOnFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAzPECSyncOnFlag);
                if( (strncmpi( Name, "AutoAzPECSyncLowHighFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAzPECSyncLowHighFlag);
                if( (strncmpi( Name, "AutoAzPECSyncDirFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAzPECSyncDirFlag);
                if( (strncmpi( Name, "AutoAzPECDeBounce", sizeof( Name))) == 0)
                        FReadFlag( Input, &AutoAzPECDeBounce);
                if( (strncmpi( Name, "FullstepsPerPECArray", sizeof( Name))) == 0)
                        FReadLong( Input, &FullstepsPerPECArray);
                if( (strncmpi( Name, "PECIxOffset.A", sizeof( Name))) == 0)
                        FReadInt( Input, &PECIxOffset.A);
                if( (strncmpi( Name, "PECIxOffset.Z", sizeof( Name))) == 0)
                        FReadInt( Input, &PECIxOffset.Z);
                if( (strncmpi( Name, "FRStepSizeArcsec", sizeof( Name))) == 0)
                        FReadDouble( Input, &FRStepSizeArcsec);
                if( (strncmpi( Name, "SectoredFRDrive", sizeof( Name))) == 0)
                        FReadFlag( Input, &SectoredFRDrive);
                if( (strncmpi( Name, "FRStepSpeedMilliSec", sizeof( Name))) == 0)
                        FReadInt( Input, &FRStepSpeedMilliSec);
                if( (strncmpi( Name, "ReverseFRMotor", sizeof( Name))) == 0)
                        FReadFlag( Input, &ReverseFRMotor);
                /* FocusMethod and MotorControlMethods are defined as enum */
                if( (strncmpi( Name, "FocusMethod", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &I);
                        FocusMethod = I;
                }
                if( (strncmpi( Name, "AltFullStepSizeArcsec", sizeof( Name))) == 0)
                        FReadDouble( Input, &AltFullStepSizeArcsec);
                if( (strncmpi( Name, "AzFullStepSizeArcsec", sizeof( Name))) == 0)
                        FReadDouble( Input, &AzFullStepSizeArcsec);
                if( (strncmpi( Name, "AzFullStepSizeArcsecCW", sizeof( Name))) == 0)
                        FReadDouble( Input, &AzFullStepSizeArcsecCW);
                if( (strncmpi( Name, "AzFullStepSizeArcsecCCW", sizeof( Name))) == 0)
                        FReadDouble( Input, &AzFullStepSizeArcsecCCW);
                if( (strncmpi( Name, "ReverseFocusMotor", sizeof( Name))) == 0)
                        FReadFlag( Input, &ReverseFocusMotor);
                if( (strncmpi( Name, "FocusFastStepsSec", sizeof( Name))) == 0)
                        FReadInt( Input, &FocusFastStepsSec);
                if( (strncmpi( Name, "FocusSlowStepsSec", sizeof( Name))) == 0)
                        FReadInt( Input, &FocusSlowStepsSec);
                if( (strncmpi( Name, "FocusPosition", sizeof( Name))) == 0)
                        FReadInt( Input, &FocusPosition);
                if( (strncmpi( Name, "MotorControlMethod", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &I);
                        MotorControlMethod = I;
                }
                if( (strncmpi( Name, "MotorWindings", sizeof( Name))) == 0)
                        FReadInt( Input, &MotorWindings);
                if( (strncmpi( Name, "InvertOutput", sizeof( Name))) == 0)
                        FReadFlag( Input, &InvertOutput);
                if( (strncmpi( Name, "KeepAlivePPortPin", sizeof( Name))) == 0)
                        FReadInt( Input, &KeepAlivePPortPin);
                if( (strncmpi( Name, "ReverseAMotor", sizeof( Name))) == 0)
                        FReadFlag( Input, &ReverseAMotor);
                if( (strncmpi( Name, "ReverseZMotor", sizeof( Name))) == 0)
                        FReadFlag( Input, &ReverseZMotor);
                if( (strncmpi( Name, "HsRampStyle", sizeof( Name))) == 0)
                        FReadFlag( Input, &HsRampStyle);
                if( (strncmpi( Name, "HsTimerFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &HsTimerFlag);
                if( (strncmpi( Name, "MaxDelay", sizeof( Name))) == 0)
                        FReadInt( Input, &MaxDelay);
                if( (strncmpi( Name, "MinDelay", sizeof( Name))) == 0)
                        FReadInt( Input, &MinDelay);
                if( (strncmpi( Name, "HsDelayX", sizeof( Name))) == 0)
                        FReadInt( Input, &HsDelayX);
                if( (strncmpi( Name, "HsRampX", sizeof( Name))) == 0)
                        FReadInt( Input, &HsRampX);
                if( (strncmpi( Name, "InterruptHs", sizeof( Name))) == 0)
                        FReadInt( Input, &InterruptHs);
                if( (strncmpi( Name, "HoldReps", sizeof( Name))) == 0)
                        FReadInt( Input, &HoldReps);
                if( (strncmpi( Name, "HsOverVoltageControl", sizeof( Name))) == 0)
                        FReadInt( Input, &HsOverVoltageControl);
                if( (strncmpi( Name, "MaxConsecutiveSlews", sizeof( Name))) == 0)
                        FReadInt( Input, &MaxConsecutiveSlews);
                if( (strncmpi( Name, "MsPowerDownSec", sizeof( Name))) == 0)
                        FReadInt( Input, &MsPowerDownSec);
                if( (strncmpi( Name, "PWMRepsTick", sizeof( Name))) == 0)
                        FReadInt( Input, &PWMRepsTick);
                if( (strncmpi( Name, "AvgPWMRepsTickOnFlag", sizeof( Name))) == 0)
                        FReadFlag( Input, &AvgPWMRepsTickOnFlag);
                if( (strncmpi( Name, "MsDelayX", sizeof( Name))) == 0)
                        FReadInt( Input, &MsDelayX);
                if( (strncmpi( Name, "MsPause", sizeof( Name))) == 0)
                        FReadInt( Input, &MsPause);
                if( (strncmpi( Name, "Ms", sizeof( Name))) == 0)
                        FReadInt( Input, &Ms);
                if( (strncmpi( Name, "MaxIncrMsPerPWM", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &MaxIncrMsPerPWM);
                        MaxIncrMsPerPWMWasRead = True;
                }
                if( (strncmpi( Name, "MsHsToggleIncrMsPerPWM", sizeof( Name))) == 0)
                {
                        FReadInt( Input, &MsHsToggleIncrMsPerPWM);
                        MsHsToggleIncrMsPerPWMWasRead = True;
                }
                if( (strncmpi( Name, "MaxPWM", sizeof( Name))) == 0)
                {
                        MaxPWMFoundFlag = Yes;
                        FReadInt( Input, &MaxPWM);
                }
                if( (strncmpi( Name, "PWM[", 4)) == 0)
                        ReadPWMValue();
                if( (strncmpi( Name, "PWMZ[", 5)) == 0)
                {
                        UsePWMZFlag = Yes;
                        ReadPWMValue();
                }
                if( (strncmpi( Name, "PWM_A", 5)) == 0)
                {
                        Ix = Name[6] - 'a';
                        if( Ix >= 0 && Ix < 4)
                        {
                                FReadDouble( Input, &PWM_A_Comp[Ix]);
                                SavePWMComp = Yes;
                        }
                        else
                                BadExit( strcat( "Bad PWM_A_? char in ", ConfigFile));
                }
                if( (strncmpi( Name, "PWM_Z", 5)) == 0)
                {
                        Ix = Name[6] - 'a';
                        if( Ix >= 0 && Ix < 4)
                        {
                                FReadDouble( Input, &PWM_Z_Comp[Ix]);
                                SavePWMComp = Yes;
                        }
                        else
                                BadExit( strcat( "Bad PWM_Z_? char in ", ConfigFile));
                }
                if( (strncmpi( Name, "QSC_", 4)) == 0)
                        if( Name[4] >= 'a' && Name[4] <= 'd')
                        {
                                UseQSC = True;
                                Ix = (Name[4] - 'a') * 4;
                                if( Name[5] >= '0' && Name[5] <= '3')
                                        Ix += Name[5] - '0';
                                FReadDouble( Input, &QSCvalues[Ix].A);
                                do
                                {
                                        C = Blank;
                                        FReadChar( Input, &C);
                                }
                                while( C != '\n' && C != ':');
                                if( C == ':')
                                        FReadDouble( Input, &QSCvalues[Ix].Z);
                        }
                if( (strncmpi( Name, "PPortAddr", sizeof( Name))) == 0)
                {
                        FReadUnsigned( Input, &PPortAddr);
                        StartPPortAddr = PPortAddr;
                }
                if( (strncmpi( Name, "Eyepieces", sizeof( Name))) == 0)
                        FReadInt( Input, &Eyepieces);
                if( Eyepieces > MAX_EYEPIECES)
                        Eyepieces = MAX_EYEPIECES;
                for (Ix=0; Ix < Eyepieces; Ix++)
                {
                        sprintf( StrCompare, "EPFocusPosition[%d].Position", Ix);
                        if( (strncmpi( Name, StrCompare, sizeof( Name))) == 0)
                                FReadInt( Input, &EPFocusPosition[Ix].Position);
                        sprintf( StrCompare, "EPFocusPosition[%d].Name", Ix);
                        if( (strncmpi( Name, StrCompare, sizeof( Name))) == 0)
                                FReadStringToCharCountOrNewLine( Input, EPFocusPosition[Ix].Name, sizeof( Name));
                };
                if( (strncmpi( Name, "COM3Base", sizeof( Name))) == 0)
                        FReadUnsigned( Input, &CommPort[Com3].Base);
                if( (strncmpi( Name, "COM3IRQ", sizeof( Name))) == 0)
                        FReadInt( Input, &CommPort[Com3].IRQ);
                if( (strncmpi( Name, "COM4Base", sizeof( Name))) == 0)
                        FReadUnsigned( Input, &CommPort[Com4].Base);
                if( (strncmpi( Name, "COM4IRQ", sizeof( Name))) == 0)
                        FReadInt( Input, &CommPort[Com4].IRQ);
                if( (strncmpi( Name, "EncoderString", sizeof( Name))) == 0)
                        FReadStringToCharCountOrNewLine( Input, EncoderString, sizeof( Name));
                if( (strncmpi( Name, "EncoderComPort", sizeof( Name))) == 0)
                        FReadInt( Input, &EncoderComPort);
                if( (strncmpi( Name, "EncoderBaudRate", sizeof( Name))) == 0)
                        FReadLong( Input, &EncoderBaudRate);
                if( (strncmpi( Name, "SerialWriteDelayMs", sizeof( Name))) == 0)
                        FReadInt( Input, &SerialWriteDelayMs);
                if( (strncmpi( Name, "AltEncoderCountsPerRev", sizeof( Name))) == 0)
                        FReadLong( Input, &AltEncoderCountsPerRev);
                if( (strncmpi( Name, "AzEncoderCountsPerRev", sizeof( Name))) == 0)
                        FReadLong( Input, &AzEncoderCountsPerRev);
                if( (strncmpi( Name, "AltEncoderDir", sizeof( Name))) == 0)
                        FReadFlag( Input, &AltEncoderDir);
                if( (strncmpi( Name, "AzEncoderDir", sizeof( Name))) == 0)
                        FReadFlag( Input, &AzEncoderDir);
                if( (strncmpi( Name, "EncoderErrorThresholdDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &EncoderErrorThresholdDeg);
                if( (strncmpi( Name, "TrackEncoderErrorThresholdDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &TrackEncoderErrorThresholdDeg);
                if( (strncmpi( Name, "MakeEncoderResetLogFile", sizeof( Name))) == 0)
                        FReadFlag( Input, &MakeEncoderResetLogFile);
                if( (strncmpi( Name, "EncoderOffset.A", sizeof( Name))) == 0)
                        FReadDouble( Input, &EncoderOffset.A);
                if( (strncmpi( Name, "EncoderOffset.Z", sizeof( Name))) == 0)
                        FReadDouble( Input, &EncoderOffset.Z);
                if( (strncmpi( Name, "LX200ComPort", sizeof( Name))) == 0)
                        FReadInt( Input, &LX200ComPort);
                if( (strncmpi( Name, "LX200BaudRate", sizeof( Name))) == 0)
                        FReadLong( Input, &LX200BaudRate);
                if( (strncmpi( Name, "LX200MotionTimeoutSec", sizeof( Name))) == 0)
                        FReadInt( Input, &LX200MotionTimeoutSec);
                if( (strncmpi( Name, "LX200SlewHs", sizeof( Name))) == 0)
                        FReadLong( Input, &LX200SlewHs);
                if( (strncmpi( Name, "LX200_LongFormat", sizeof( Name))) == 0)
                        FReadFlag( Input, &LX200_LongFormat);
                if( (strncmpi( Name, "Current.Alt", sizeof( Name))) == 0)
                {
                        FReadDouble( Input, &Current.Alt);
                        Current.Alt *= DegToRad;
                }
                if( (strncmpi( Name, "Current.Az", sizeof( Name))) == 0)
                {
                        FReadDouble( Input, &Current.Az);
                        Current.Az *= DegToRad;
                }
                if( (strncmpi( Name, "AccumMs.A", sizeof( Name))) == 0)
                        FReadLong( Input, &AccumMs.A);
                if( (strncmpi( Name, "AccumMs.Z", sizeof( Name))) == 0)
                        FReadLong( Input, &AccumMs.Z);
                if( (strncmpi( Name, "StartInitState", sizeof( Name))) == 0)
                        FReadInt( Input, &StartInitState);
                if( (strncmpi( Name, "InitOne", sizeof( Name))) == 0)
                        FReadPositionToNewLine( Input, &One);
                if( (strncmpi( Name, "InitTwo", sizeof( Name))) == 0)
                        FReadPositionToNewLine( Input, &Two);
                if( (strncmpi( Name, "InitThree", sizeof( Name))) == 0)
                        FReadPositionToNewLine( Input, &Three);
                if( (strncmpi( Name, "Z1Deg", sizeof( Name))) == 0)
                        FReadDouble( Input, &Z1Deg);
                if( (strncmpi( Name, "Z2Deg", sizeof( Name))) == 0)
                        FReadDouble( Input, &Z2Deg);
                if( (strncmpi( Name, "Z3Deg", sizeof( Name))) == 0)
                        FReadDouble( Input, &Z3Deg);
                if( (strncmpi( Name, "DataFileCoordYear", sizeof( Name))) == 0)
                        FReadDouble( Input, &DataFileCoordYear);
                if( (strncmpi( Name, "LatitudeDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &LatitudeDeg);
                if( (strncmpi( Name, "CMOS_RTC_Access", sizeof( Name))) == 0)
                        FReadFlag( Input, &CMOS_RTC_Access);
                if( (strncmpi( Name, "LongitudeDeg", sizeof( Name))) == 0)
                        FReadDouble( Input, &LongitudeDeg);
                if( (strncmpi( Name, "Height", sizeof( Name))) == 0)
                        FReadDouble( Input, &Height);
                if( (strncmpi( Name, "Tz", sizeof( Name))) == 0)
                        FReadDouble( Input, &Tz);
                if( (strncmpi( Name, "DST", sizeof( Name))) == 0)
                        FReadInt( Input, &DST);
                if( (strncmpi( Name, "TestString", sizeof( Name))) == 0)
                        FReadStringToCharCountOrNewLine( Input, TestString, sizeof( Name));
                fscanf( Input, "%s", Name);
        }
        fclose( Input);

        if( !MaxIncrMsPerPWMWasRead)
                MaxIncrMsPerPWM = Ms/2;

        if( !MsHsToggleIncrMsPerPWMWasRead)
                MsHsToggleIncrMsPerPWM = Ms/4;

        if( LongitudeDeg < 0)
                LongitudeDeg = 360. + LongitudeDeg;

        if( AutoGEMFlip)
                GEMFlipPossible = True;

        if( AutoAltPECDeBounce)
                AutoAltPECDeBounce = 1;
        if( AutoAzPECDeBounce)
                AutoAzPECDeBounce = 1;
}

void ReadPWMValue( void)
{
        char C;
        int Index;

        Ix = 0;
        /* read through first left bracket */
        while( Ix < NameSize)
                if( Name[Ix++] == '[')
                        break;
        if( Ix == NameSize)
                if( UsePWMZFlag)
                        BadExit( "couldn't find '[' in \"PWMZ[...\"");
                else
                        BadExit( "couldn't find '[' in \"PWM[...\"");
        if( Name[Ix] >= '0' && Name[Ix] <= '9')
                Index = Name[Ix] - '0';
        else
                if( UsePWMZFlag)
                        BadExit( "couldn't find first Index digit in \"PWMZ[...\"");
                else
                        BadExit( "couldn't find first Index digit in \"PWM[...\"");
        Ix++;
        if( Name[Ix] >= '0' && Name[Ix] <= '9')
                Index = Index*10 + Name[Ix] - '0';
        else
                if( Name[Ix] != ']')
                        if( UsePWMZFlag)
                                BadExit( "couldn't find ']' in \"PWMZ[...]\"");
                        else
                                BadExit( "couldn't find ']' in \"PWM[...]\"");
        if( UsePWMZFlag)
                FReadInt( Input, &PWMZ[Index].A);
        else
                FReadInt( Input, &PWM[Index].A);
        do
        {
                C = Blank;
                FReadChar( Input, &C);
        }
        while( C != '\n' && C != ':');
        if( C == ':')
        {
                if( UsePWMZFlag)
                {
                        UseComplexPWMZFlag = Yes;
                        FReadInt( Input, &PWMZ[Index].Z);
                }
                else
                {
                        UseComplexPWMFlag = Yes;
                        FReadInt( Input, &PWM[Index].Z);
                }
        }
}

void AskAndWriteConfig( void)
{
        printf( "\nsave %s ('y' for yes, any other key to ignore)? ", ConfigFile);
        Response = getch();
        printf( "%c", Response);
        if( Response == 'Y' || Response == 'y' || Response == Return)
                WriteConfig();
}

void WriteConfig( void)
{
        time_t t;

        Output = fopen( ConfigFile, "w");
        if( Output == NULL)
                BadExit( strcat( "Could not create ", ConfigFile));

        time( &t);
        /* ctime() ends with \n\0 */
        fprintf( Output, ";created on %s", ctime( &t));

        fprintf( Output, "\n[*** display section ***]\n");
        fprintf( Output, "DefaultBackground %d\n", DefaultBackground);
        fprintf( Output, "DefaultColor %d\n", DefaultColor);
        fprintf( Output, "TitleColor %d\n", TitleColor);
        fprintf( Output, "BorderColor %d\n", BorderColor);
        fprintf( Output, "MenuColor %d\n", MenuColor);
        fprintf( Output, "DisplayColor %d\n", DisplayColor);
        fprintf( Output, "SelectColor %d\n", SelectColor);
        fprintf( Output, "CurrentColor %d\n", CurrentColor);
        fprintf( Output, "SelectBackground %d\n", SelectBackground);
        fprintf( Output, "ConfirmQuit %d\n", ConfirmQuit);
        fprintf( Output, "DisplayOpeningMsgs %d\n", DisplayOpeningMsgs);
        fprintf( Output, "HorizonLimitFlag %d\n", HorizonLimitFlag);
        fprintf( Output, "MoveHsMsgDeg %f\n", MoveHsMsgDeg);

        fprintf( Output, "\n[*** hotkey section ***]\n");
        if( HotkeyF9Set)
                fprintf( Output, "HotkeyF9 %d\n", HotkeyF9);
        if( HotkeyF10Set)
                fprintf( Output, "HotkeyF10 %d\n", HotkeyF10);
        if( HotkeyF11Set)
                fprintf( Output, "HotkeyF11 %d\n", HotkeyF11);
        if( HotkeyF12Set)
                fprintf( Output, "HotkeyF12 %d\n", HotkeyF12);

        fprintf( Output, "\n[*** interface section ***]\n");
        fprintf( Output, "InterfacePath %s\n", InterfacePath);

        fprintf( Output, "\n[*** control section ***]\n");
        fprintf( Output, "UseMouseFlag %d\n", UseMouseFlag);
        fprintf( Output, "IACA_Flag %d\n", IACA_Flag);

        fprintf( Output, "\n[*** mount section ***]\n");
        fprintf( Output, "GEMFlipPossible %d\n", GEMFlipPossible);
        fprintf( Output, "AutoGEMFlip %d\n", AutoGEMFlip);
        fprintf( Output, "AutoGEMFlipOnFuzzDeg %f\n", AutoGEMFlipOnFuzzDeg);
        fprintf( Output, "AutoGEMFlipOffFuzzDeg %f\n", AutoGEMFlipOffFuzzDeg);
        fprintf( Output, "Siderostat %d\n", Siderostat);
        fprintf( Output, "HomeAltDeg %f\n", HomeAltDeg);
        fprintf( Output, "HomeAzDeg %f\n", HomeAzDeg);
        fprintf( Output, "MsArcsecSec %d\n", MsArcsecSec);

        fprintf( Output, "\n[*** error correction section ***]\n");
        fprintf( Output, "precessionNutationAberration %d\n", precessionNutationAberration);
        fprintf( Output, "RefractFlag %d\n", RefractFlag);
        fprintf( Output, "UseAltAzECFlag %d\n", UseAltAzECFlag);
        fprintf( Output, "UseAltAltECFlag %d\n", UseAltAltECFlag);
        fprintf( Output, "UseAzAzECFlag %d\n", UseAzAzECFlag);
        fprintf( Output, "PointingModelFlag %d\n", PointingModelFlag);

        fprintf( Output, "\n[*** Handpad section ***]\n");
        fprintf( Output, "HandpadPresentFlag %d\n", HandpadPresentFlag);
        fprintf( Output, "StartingHandpadMode %d\n", HandpadFlag);
        fprintf( Output, "HandpadDesign %d\n", HandpadDesign);
        fprintf( Output, "UpDownButtonsReversedFlag %d\n", UpDownButtonsReversedFlag);
        fprintf( Output, "HandpadFlipUpDownWithGEMFlip %d\n", HandpadFlipUpDownWithGEMFlip);

        fprintf( Output, "\n[*** backlash section ***]\n");
        fprintf( Output, "AltBacklashArcmin %f\n", NegBacklash.A? -AltBacklashArcmin: AltBacklashArcmin);
        fprintf( Output, "AzBacklashArcmin %f\n", NegBacklash.Z? -AzBacklashArcmin: AzBacklashArcmin);
        fprintf( Output, "ABacklashSignalPPortPin17 %d\n", ABacklashSignalPPortPin17);

        fprintf( Output, "\n[*** limit move section ***]\n");
        fprintf( Output, "AltLowLimitDeg %f\n", AltLowLimitDeg);
        fprintf( Output, "AltHighLimitDeg %f\n", AltHighLimitDeg);
        fprintf( Output, "AzLowLimitDeg %f\n", AzLowLimitDeg);
        fprintf( Output, "AzHighLimitDeg %f\n", AzHighLimitDeg);

        fprintf( Output, "\n[*** guide section ***]\n");
        fprintf( Output, "GuideArcsecSec %d\n", GuideArcsecSec);
        fprintf( Output, "GuideDragAltArcsecPerMin %f\n", GuideDragAltArcsecPerMin);
        fprintf( Output, "GuideDragAzArcsecPerMin %f\n", GuideDragAzArcsecPerMin);
        fprintf( Output, "GuideDragRaArcsecPerMin %f\n", GuideDragRaArcsecPerMin);
        fprintf( Output, "GuideDragDecArcsecPerMin %f\n", GuideDragDecArcsecPerMin);
        fprintf( Output, "HPUpdateDriftFlag %d\n", HPUpdateDriftFlag);

        fprintf( Output, "\n[*** drift section ***]\n");
        fprintf( Output, "DriftAltArcsecPerMin %f\n", Drift.Alt*RadToArcsec);
        fprintf( Output, "DriftAzArcsecPerMin %f\n", Drift.Az*RadToArcsec);
        fprintf( Output, "DriftRaDegPerHr %f\n", Drift.Ra*RadToDeg);
        fprintf( Output, "DriftDecDegPerHr %f\n", Drift.Dec*RadToDeg);

        fprintf( Output, "\n[*** PEC section ***]\n");
        fprintf( Output, "PECFlag %d\n", PECFlag);
        fprintf( Output, "AutoAltPECPin %ld\n", AutoAltPECPin);
        fprintf( Output, "AutoAltPECSyncOnFlag %d\n", AutoAltPECSyncOnFlag);
        fprintf( Output, "AutoAltPECSyncLowHighFlag %d\n", AutoAltPECSyncLowHighFlag);
        fprintf( Output, "AutoAltPECSyncDirFlag %d\n", AutoAltPECSyncDirFlag);
        fprintf( Output, "AutoAltPECDeBounce %d\n", AutoAltPECDeBounce);
        fprintf( Output, "AutoAzPECPin %ld\n", AutoAzPECPin);
        fprintf( Output, "AutoAzPECSyncOnFlag %d\n", AutoAzPECSyncOnFlag);
        fprintf( Output, "AutoAzPECSyncLowHighFlag %d\n", AutoAzPECSyncLowHighFlag);
        fprintf( Output, "AutoAzPECSyncDirFlag %d\n", AutoAzPECSyncDirFlag);
        fprintf( Output, "AutoAzPECDeBounce %d\n", AutoAzPECDeBounce);
        fprintf( Output, "FullstepsPerPECArray %ld\n", FullstepsPerPECArray);
        fprintf( Output, "PECIxOffset.A %d\n", PECIxOffset.A);
        fprintf( Output, "PECIxOffset.Z %d\n", PECIxOffset.Z);

        fprintf( Output, "\n[*** field rotation section ***]\n");
        fprintf( Output, "FRStepSizeArcsec %f\n", FRStepSizeArcsec);
        fprintf( Output, "SectoredFRDrive %d\n", SectoredFRDrive);
        fprintf( Output, "FRStepSpeedMilliSec %d\n", FRStepSpeedMilliSec);
        fprintf( Output, "ReverseFRMotor %d\n", ReverseFRMotor);

        fprintf( Output, "\n[*** focus section ***]\n");
        fprintf( Output, "FocusMethod %d\n", FocusMethod);
        fprintf( Output, "ReverseFocusMotor %d\n", ReverseFocusMotor);
        fprintf( Output, "FocusFastStepsSec %d\n", FocusFastStepsSec);
        fprintf( Output, "FocusSlowStepsSec %d\n", FocusSlowStepsSec);
        fprintf( Output, "FocusPosition %d\n", FocusPosition);

        fprintf( Output, "\n[*** motor setup section ***]\n");
        fprintf( Output, "MotorControlMethod %d\n", MotorControlMethod);
        fprintf( Output, "MotorWindings %d\n", MotorWindings);
        fprintf( Output, "InvertOutput %d\n", InvertOutput);
        fprintf( Output, "KeepAlivePPortPin %d\n", KeepAlivePPortPin);
        fprintf( Output, "AltFullStepSizeArcsec %f\n", AltFullStepSizeArcsec);
        fprintf( Output, "AzFullStepSizeArcsec %f\n", AzFullStepSizeArcsec);
        fprintf( Output, "AzFullStepSizeArcsecCW %f\n", AzFullStepSizeArcsecCW);
        fprintf( Output, "AzFullStepSizeArcsecCCW %f\n", AzFullStepSizeArcsecCCW);
        fprintf( Output, "ReverseAMotor %d\n", ReverseAMotor);
        fprintf( Output, "ReverseZMotor %d\n", ReverseZMotor);

        fprintf( Output, "\n[*** halfstep section ***]\n");
        fprintf( Output, "HsRampStyle %d\n", HsRampStyle);
        fprintf( Output, "HsTimerFlag %d\n", HsTimerFlag);
        fprintf( Output, "MaxDelay %d\n", MaxDelay);
        fprintf( Output, "MinDelay %d\n", MinDelay);
        fprintf( Output, "HsDelayX %d\n", HsDelayX);
        fprintf( Output, "HsRampX %d\n", HsRampX);
        fprintf( Output, "InterruptHs %d\n", InterruptHs);
        fprintf( Output, "HoldReps %d\n", HoldReps);
        fprintf( Output, "HsOverVoltageControl %d\n", HsOverVoltageControl);
        fprintf( Output, "MaxConsecutiveSlews %d\n", MaxConsecutiveSlews);

        fprintf( Output, "\n[*** microstep section ***]\n");
        fprintf( Output, "MsPowerDownSec %d\n", MsPowerDownSec);
        fprintf( Output, "PWMRepsTick %d\n", PWMRepsTick);
        fprintf( Output, "AvgPWMRepsTickOnFlag %d\n", AvgPWMRepsTickOnFlag);
        fprintf( Output, "MsDelayX %d\n", MsDelayX);
        fprintf( Output, "MsPause %d\n", MsPause);
        fprintf( Output, "Ms %d\n", Ms);
        fprintf( Output, "MaxIncrMsPerPWM %d\n", MaxIncrMsPerPWM);
        fprintf( Output, "MsHsToggleIncrMsPerPWM %d\n", MsHsToggleIncrMsPerPWM);
        fprintf( Output, "MaxPWM %d\n", MaxPWM);
        for( Ix = 0; Ix < Ms; Ix++)
        {
                fprintf( Output, "PWM[%*d] %d", Ix<10?1:2, Ix, PWM[Ix].A);
                if( UseComplexPWMFlag)
                        fprintf( Output, " : %d\n", PWM[Ix].Z);
                else
                        if( Ix)
                                fprintf( Output, " : %d\n", PWM[Ms-Ix].A);
                        else
                                fprintf( Output, " : 0\n");
        }
        if( UsePWMZFlag)
                for( Ix = 0; Ix < Ms; Ix++)
                {
                        fprintf( Output, "PWMZ[%*d] %d", Ix<10?1:2, Ix, PWMZ[Ix].A);
                        if( UseComplexPWMZFlag)
                                fprintf( Output, " : %d\n", PWMZ[Ix].Z);
                        else
                                if( Ix)
                                        fprintf( Output, " : %d\n", PWMZ[Ms-Ix].A);
                                else
                                        fprintf( Output, " : 0\n");
                }
        for( Ix = 0; Ix < MotorWindings; Ix++)
        {
                if( SavePWMComp)
                {
                        for( Ix = 0; Ix < MotorWindings; Ix++)
                                fprintf( Output, "PWM_A_%c_Comp %1.3f\n", 'a'+Ix, PWM_A_Comp[Ix]);
                        for( Ix = 0; Ix < MotorWindings; Ix++)
                                fprintf( Output, "PWM_Z_%c_Comp %1.3f\n", 'a'+Ix, PWM_Z_Comp[Ix]);
                        break;
                }
        }
        if( UseQSC)
                for( Ix = 0; Ix < MotorWindings*4; Ix++)
                        fprintf( Output, "QSC_%c%c %3.3f : %3.3f\n", 'a'+Ix/4, '0'+Ix%4, QSCvalues[Ix].A,
                        QSCvalues[Ix].Z);

        fprintf( Output, "\n[*** parallel port section ***]\n");
        fprintf( Output, "PPortAddr %d\n", StartPPortAddr);

        fprintf( Output, "\n[*** serial port section ***]\n");
        fprintf( Output, "'COM1 hardcoded to base address of 1016 (0x3F8) with IRQ4\n");
        fprintf( Output, "'COM2 hardcoded to base address of  760 (0x2F8) with IRQ3\n");
        fprintf( Output, "COM3Base %u\n", CommPort[Com3].Base);
        fprintf( Output, "COM3IRQ %d\n", CommPort[Com3].IRQ);
        fprintf( Output, "COM4Base %u\n", CommPort[Com4].Base);
        fprintf( Output, "COM4IRQ %d\n", CommPort[Com4].IRQ);

        fprintf( Output, "\n[*** encoder section ***]\n");
        fprintf( Output, ";EncoderString NoEncoders\n");
        fprintf( Output, ";EncoderString Bseg\n");
        fprintf( Output, ";EncoderString ResetViaR\n");
        fprintf( Output, ";EncoderString ResetViaZ\n");
        fprintf( Output, ";EncoderString NoReset\n");
        fprintf( Output, ";EncoderString Mouse\n");
        fprintf( Output, ";EncoderString Ek\n");
        fprintf( Output, ";EncoderString SkyCommander\n");
        fprintf( Output, "EncoderString %s\n", EncoderString);
        fprintf( Output, "EncoderComPort %d\n", EncoderComPort);
        fprintf( Output, "EncoderBaudRate %ld\n", EncoderBaudRate);
        fprintf( Output, "SerialWriteDelayMs %d\n", SerialWriteDelayMs);
        fprintf( Output, "AltEncoderCountsPerRev %ld\n", AltEncoderCountsPerRev);
        fprintf( Output, "AzEncoderCountsPerRev %ld\n", AzEncoderCountsPerRev);
        fprintf( Output, "AltEncoderDir %d\n", AltEncoderDir);
        fprintf( Output, "AzEncoderDir %d\n", AzEncoderDir);
        fprintf( Output, "EncoderErrorThresholdDeg %f\n", EncoderErrorThresholdDeg);
        fprintf( Output, "TrackEncoderErrorThresholdDeg %f\n", TrackEncoderErrorThresholdDeg);
        fprintf( Output, "MakeEncoderResetLogFile %d\n", MakeEncoderResetLogFile);
        fprintf( Output, "EncoderOffset.A %f\n", EncoderOffset.A);
        fprintf( Output, "EncoderOffset.Z %f\n", EncoderOffset.Z);

        fprintf( Output, "\n[*** LX200 protocol input section ***]\n");
        fprintf( Output, "LX200ComPort %d\n", LX200ComPort);
        fprintf( Output, "LX200BaudRate %ld\n", LX200BaudRate);
        fprintf( Output, "LX200MotionTimeoutSec %d\n", LX200MotionTimeoutSec);
        fprintf( Output, "LX200SlewHs %ld\n", LX200SlewHs);
        fprintf( Output, "LX200_LongFormat %d\n", LX200_LongFormat);

        fprintf( Output, "\n[*** coordinate conversion section ***]\n");
        fprintf( Output, "Current.Alt %f\n", Current.Alt*RadToDeg);
        fprintf( Output, "Current.Az %f\n", Current.Az*RadToDeg);
        fprintf( Output, "AccumMs.A %ld\n", AccumMs.A);
        fprintf( Output, "AccumMs.Z %ld\n", AccumMs.Z);
        fprintf( Output, "StartInitState %d\n", StartInitState);
        if( One.Init)
        {
                fprintf( Output, "InitOne ");
                FWritePosition( Output, &One, Yes);
        }
        if( Two.Init)
        {
                fprintf( Output, "InitTwo ");
                FWritePosition( Output, &Two, Yes);
        }
        if( Three.Init)
        {
                fprintf( Output, "InitThree ");
                FWritePosition( Output, &Three, Yes);
        }
        fprintf( Output, "Z1Deg %f\n", Z1Deg);
        fprintf( Output, "Z2Deg %f\n", Z2Deg);
        fprintf( Output, "Z3Deg %f\n", Z3Deg);
        fprintf( Output, "DataFileCoordYear %f\n", DataFileCoordYear);

        fprintf( Output, "\n[*** astronomical times section ***]\n");
        fprintf( Output, "LatitudeDeg %f\n", LatitudeDeg);
        fprintf( Output, "CMOS_RTC_Access %d\n", CMOS_RTC_Access);
        fprintf( Output, "LongitudeDeg %f\n", LongitudeDeg);
        fprintf( Output, "Height %f\n", Height);
        fprintf( Output, "Tz %f\n", Tz);
        fprintf( Output, "DST %d\n", DST);

        fprintf( Output, "\n[*** Eyepieces section (maximum of %d Eyepieces) ***]\n", MAX_EYEPIECES);
        fprintf( Output, "Eyepieces %d\n", Eyepieces);
        for( Ix = 0; Ix < Eyepieces; Ix++)
                {
                        fprintf( Output, "EPFocusPosition[%d].Position %d \n", Ix, EPFocusPosition[Ix].Position);
                        fprintf( Output, "EPFocusPosition[%d].Name %s\n", Ix, EPFocusPosition[Ix].Name);
                };

        fprintf( Output, "\n[*** test section ***]\n");
        fprintf( Output, ";TestString NoTest\n");
        //fprintf( Output, ";TestString TestSerial\n");
        //fprintf( Output, ";TestString TestVideo\n");
        //fprintf( Output, ";TestString TestATimes\n");
        //fprintf( Output, ";TestString TestParallelPort\n");
        //fprintf( Output, ";TestString TestMouse\n");
        //fprintf( Output, ";TestString TestEncoders\n");
        //fprintf( Output, ";TestString TestHandpad\n");
        //fprintf( Output, ";TestString TestConversion\n");
        //fprintf( Output, ";TestString TestAltOffset\n");
        //fprintf( Output, ";TestString TestZ1Z2\n");
        //fprintf( Output, ";TestString TestIACA\n");
        //fprintf( Output, ";TestString WritePWMValues\n");
        //fprintf( Output, ";TestString Track\n");
        //fprintf( Output, ";TestString Track2Motors2Rates\n");
        fprintf( Output, ";TestString PreloadGuidexx.dat\n");
        fprintf( Output, "TestString %s\n", TestString);

        fclose( Output);
}

